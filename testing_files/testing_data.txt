These are examples of YAML files lacking metadata. Each example is followed by the correct completion of the YAML file, including the metadata.
Example YAML file without metadata:

rules:
  - id: duplicate-id
    message: >-
      The 'id' field $X was used multiple times.
      The 'id' field needs to be unique.
    severity: ERROR
    languages: [yaml]
    patterns:
      - pattern-inside: "rules: [..., $RULE, ...]"
      # nosemgrep: yaml.semgrep.slow-pattern-top-ellipsis
      - pattern-inside: |
          ...
          - id: $X
            ...
          ...
          - id: $X
            ...
          ...
      - pattern: |
          id: $X
    metadata:

Completed YAML file with metadata:

rules:
  - id: duplicate-id
    message: >-
      The 'id' field $X was used multiple times.
      The 'id' field needs to be unique.
    severity: ERROR
    languages: [yaml]
    patterns:
      - pattern-inside: "rules: [..., $RULE, ...]"
      # nosemgrep: yaml.semgrep.slow-pattern-top-ellipsis
      - pattern-inside: |
          ...
          - id: $X
            ...
          ...
          - id: $X
            ...
          ...
      - pattern: |
          id: $X
    metadata:
      category: correctness
      technology:
        - semgrep


Example YAML file without metadata:

rules:
  - id: duplicate-pattern
    message: >-
      Two identical pattern clauses were detected.
      This will cause Semgrep to run the same pattern twice.
      Remove one of the duplicate pattern clauses.
    severity: ERROR
    languages: [yaml]
    patterns:
      - pattern-inside: "rules: [..., $RULE, ...]"
      - pattern-inside: |
          - pattern: $X
          ...
          - pattern: $X
          ...
      - pattern: |
          pattern: $X
    metadata:

Completed YAML file with metadata:

rules:
  - id: duplicate-pattern
    message: >-
      Two identical pattern clauses were detected.
      This will cause Semgrep to run the same pattern twice.
      Remove one of the duplicate pattern clauses.
    severity: ERROR
    languages: [yaml]
    patterns:
      - pattern-inside: "rules: [..., $RULE, ...]"
      - pattern-inside: |
          - pattern: $X
          ...
          - pattern: $X
          ...
      - pattern: |
          pattern: $X
    metadata:
      category: correctness
      technology:
        - semgrep


Example YAML file without metadata:

rules:
  - id: empty-message
    message: >-
      This rule has an empty message field.
      Consider adding a message field that communicates why this
      rule is an issue and how to fix it. This will increase the
      chance that the finding gets addressed.
    languages: [yaml]
    patterns:
      - pattern-inside: "rules: [..., $RULE, ...]"
      - pattern: |
          message: ""
    severity: WARNING
    metadata:

Completed YAML file with metadata:

rules:
  - id: empty-message
    message: >-
      This rule has an empty message field.
      Consider adding a message field that communicates why this
      rule is an issue and how to fix it. This will increase the
      chance that the finding gets addressed.
    languages: [yaml]
    patterns:
      - pattern-inside: "rules: [..., $RULE, ...]"
      - pattern: |
          message: ""
    severity: WARNING
    metadata:
      category: correctness
      technology:
        - semgrep


Example YAML file without metadata:

rules:
  - id: message-whitespace-check
    message: >-
      It looks like you have an additional space in your rule message, this
      can look awkward in the finding output, please remove the additional
      whitespace!
    languages:
      - yaml
    severity: WARNING
    metadata:

Completed YAML file with metadata:

rules:
  - id: message-whitespace-check
    message: >-
      It looks like you have an additional space in your rule message, this
      can look awkward in the finding output, please remove the additional
      whitespace!
    languages:
      - yaml
    severity: WARNING
    metadata:
      references:
        - https://semgrep.dev/docs/contributing/contributing-to-semgrep-rules-repository
      category: correctness
      technology:
        - semgrep
    patterns:
      - pattern-inside: |
          rules: ...
      - pattern: |
          message: >-
            $VALUE
      - focus-metavariable:
          - $VALUE
      - pattern-regex: \w.*
      - pattern-regex: \s{2,}
    fix-regex:
      regex: (?<=\S)\s(\s{1,})
      replacement: " "


Example YAML file without metadata:

rules:
  # ruleid: metadata-category
  - id: unchecked-subprocess-call
    patterns:
      - pattern-either:
          - pattern: |
              subprocess.call(...)
          - pattern: |
              subprocess.call(...)
      - pattern-not-inside: |
          $S = subprocess.call(...)
      - pattern-not-inside: |
          subprocess.call(...) == $X
    message: >-
      bad stuff
    severity: WARNING
    fix: subprocess.check_call(...)
  # ok: metadata-category
  - id: subprocess-run
    patterns: subprocess.run(...)
    message: >-
      bad stuff
    severity: WARNING
    fix: subprocess.check_call(...)
    metadata:

Completed YAML file with metadata:

rules:
  # ruleid: metadata-category
  - id: unchecked-subprocess-call
    patterns:
      - pattern-either:
          - pattern: |
              subprocess.call(...)
          - pattern: |
              subprocess.call(...)
      - pattern-not-inside: |
          $S = subprocess.call(...)
      - pattern-not-inside: |
          subprocess.call(...) == $X
    message: >-
      bad stuff
    severity: WARNING
    fix: subprocess.check_call(...)
  # ok: metadata-category
  - id: subprocess-run
    patterns: subprocess.run(...)
    message: >-
      bad stuff
    severity: WARNING
    fix: subprocess.check_call(...)
    metadata:
      category: python
  - metadata:
      category: python
    # ok: metadata-category
    id: subprocess-run-2
    patterns: subprocess.run(...)
    message: >-
      bad stuff
    severity: WARNING
    fix: subprocess.check_call(...)


Example YAML file without metadata:

rules:
  - id: metadata-category
    message: >-
      This Semgrep rule is missing a valid 'category' field in the 'metadata'.
      'category' must be one of 'security', 'correctness', 'best-practice',
      'performance', 'maintainability', or 'portability'.
    severity: INFO
    patterns:
      - pattern-inside: "rules: [..., $RULE, ...]"
      - pattern: "id: $RULEID"
      - pattern-not-inside: |
          - ...
            metadata:

Completed YAML file with metadata:

rules:
  - id: metadata-category
    message: >-
      This Semgrep rule is missing a valid 'category' field in the 'metadata'.
      'category' must be one of 'security', 'correctness', 'best-practice',
      'performance', 'maintainability', or 'portability'.
    severity: INFO
    patterns:
      - pattern-inside: "rules: [..., $RULE, ...]"
      - pattern: "id: $RULEID"
      - pattern-not-inside: |
          - ...
            metadata:
              ...
              category: $CATEGORY
    languages: [yaml]
    metadata:
      category: best-practice
      technology:
        - semgrep


Example YAML file without metadata:

rules:
  - id: require-request
    message: >-
      If an attacker controls the x in require(x) then they can cause code to load that was not intended to run on the server.
    severity: LOW
    languages: [javascript, typescript]
    metadata:

Completed YAML file with metadata:

rules:
  - id: require-request
    message: >-
      If an attacker controls the x in require(x) then they can cause code to load that was not intended to run on the server.
    severity: LOW
    languages: [javascript, typescript]
    metadata:
      owasp: "A03:2021 - Injection"
      cwe: "CWE-706: Use of Incorrectly-Resolved Name or Reference"
      source-rule-url: https://nodesecroadmap.fyi/chapter-1/threat-UIR.html
      category: security
      likelihood: lOW
      # ruleid: metadata-confidence-incorrect-value
      confidence: lOW
      technology:
        - express
      references:
        - https://github.com/google/node-sec-roadmap/blob/master/chapter-2/dynamism.md#dynamism-when-you-need-it
    patterns: 
  - id: require-request
    message: >-
      If an attacker controls the x in require(x) then they can cause code to load that was not intended to run on the server.
    severity: LOW
    languages: [javascript, typescript]
    metadata:
      owasp: "A03:2021 - Injection"
      cwe: "CWE-706: Use of Incorrectly-Resolved Name or Reference"
      source-rule-url: https://nodesecroadmap.fyi/chapter-1/threat-UIR.html
      category: security
      # ok: metadata-confidence-incorrect-value
      confidence: LOW
      technology:
        - express
      references:
        - https://github.com/google/node-sec-roadmap/blob/master/chapter-2/dynamism.md#dynamism-when-you-need-it
    patterns: 


Example YAML file without metadata:

rules:
  - id: metadata-confidence-incorrect-value
    patterns:
      - pattern-inside: |
          rules: 
            ...
      - pattern-inside: |
          metadata:

Completed YAML file with metadata:

rules:
  - id: metadata-confidence-incorrect-value
    patterns:
      - pattern-inside: |
          rules: 
            ...
      - pattern-inside: |
          metadata: 
            ...
            category: security
            ...
      - pattern: |
          confidence: $VALUE
      - pattern-not: |
          confidence: LOW
      - pattern-not: |
          confidence: MEDIUM
      - pattern-not: |
          confidence: HIGH
    message: >-
      Semgrep rule confidence: $VALUE detected, but the value must be LOW,
      MEDIUM, or HIGH. For more information visit: 
      https://semgrep.dev/docs/contributing/contributing-to-semgrep-rules-repository/
    languages:
      - yaml
    severity: WARNING
    metadata:
      references:
        - https://semgrep.dev/docs/contributing/contributing-to-semgrep-rules-repository/
      category: correctness
      technology:
        - semgrep

Example YAML file without metadata:

rules:
  - id: require-request
    message: >-
      If an attacker controls the x in require(x) then they can cause code to load that was not intended to run on the server.
    severity: LOW
    languages: [javascript, typescript]
    # ok: metadata-confidence
    metadata:

Completed YAML file with metadata:

rules:
  - id: require-request
    message: >-
      If an attacker controls the x in require(x) then they can cause code to load that was not intended to run on the server.
    severity: LOW
    languages: [javascript, typescript]
    # ok: metadata-confidence
    metadata:
      owasp: "A03:2021 - Injection"
      cwe: "CWE-706: Use of Incorrectly-Resolved Name or Reference"
      source-rule-url: https://nodesecroadmap.fyi/chapter-1/threat-UIR.html
      category: security
      likelihood: LOW
      impact: LOW
      confidence: LOW
      technology:
        - express
      references:
        - https://github.com/google/node-sec-roadmap/blob/master/chapter-2/dynamism.md#dynamism-when-you-need-it
    patterns: 
  - id: require-request
    message: >-
      If an attacker controls the x in require(x) then they can cause code to load that was not intended to run on the server.
    severity: LOW
    languages: [javascript, typescript]
    # ruleid: metadata-confidence
    metadata:
      owasp: "A03:2021 - Injection"
      cwe: "CWE-706: Use of Incorrectly-Resolved Name or Reference"
      source-rule-url: https://nodesecroadmap.fyi/chapter-1/threat-UIR.html
      category: security
      technology:
        - express
      references:
        - https://github.com/google/node-sec-roadmap/blob/master/chapter-2/dynamism.md#dynamism-when-you-need-it
    patterns: 


Example YAML file without metadata:

rules:
  - id: metadata-confidence
    patterns:
      - pattern-inside: |
          rules: 
            ...
      - pattern-inside: |
          metadata:

Completed YAML file with metadata:

rules:
  - id: metadata-confidence
    patterns:
      - pattern-inside: |
          rules: 
            ...
      - pattern-inside: |
          metadata: 
            ...
            category: security
            ...
      - pattern-not-inside: |
          metadata: 
            ...
            confidence: $VALUE
    message: >-
      This Semgrep rule is missing a valid 'confidence' field in the 'metadata'.
      which should be either LOW, MEDIUM, or HIGH. For more information visit 
      https://semgrep.dev/docs/contributing/contributing-to-semgrep-rules-repository/
    languages:
      - yaml
    severity: WARNING
    metadata:
      references:
        - https://semgrep.dev/docs/contributing/contributing-to-semgrep-rules-repository
      category: correctness
      technology:
        - semgrep

Example YAML file without metadata:

rules:
  - id: example-1
    message: Example
    severity: ERROR
    languages: [json, yaml]
    pattern: "..."
    metadata:

Completed YAML file with metadata:

rules:
  - id: example-1
    message: Example
    severity: ERROR
    languages: [json, yaml]
    pattern: "..."
    metadata:
      # ok: metadata-cwe
      cwe: "CWE-123: Some Vulnerability"
  - id: example-2
    message: Example
    severity: ERROR
    languages: [json, yaml]
    pattern: "..."
    metadata:
      # ruleid: metadata-cwe
      cwe: "CWE123: Some Vulnerability"
  - id: example-3
    message: Example
    severity: ERROR
    languages: [json, yaml]
    pattern: "..."
    metadata:
      # ruleid: metadata-cwe
      cwe: "cwe-123: Some Vulnerability"
  - id: example-4
    message: Example
    severity: ERROR
    languages: [json, yaml]
    pattern: "..."
    metadata:
      # ruleid: metadata-cwe
      cwe: CWE-123
  - id: example-4
    message: Example
    severity: ERROR
    languages: [json, yaml]
    pattern: "..."
    metadata:
      # ok: metadata-cwe
      cwe: >
        CWE-123: Some Vulnerability


Example YAML file without metadata:

rules:
  - id: metadata-cwe
    message: >-
      $...CWE The cwe tag in rule metadata should always be in the format "CWE-000: Title".
    severity: ERROR
    languages: [yaml]
    patterns:
      - pattern-inside: "rules: ..."
      - pattern-inside: "metadata:

Completed YAML file with metadata:

rules:
  - id: metadata-cwe
    message: >-
      $...CWE The cwe tag in rule metadata should always be in the format "CWE-000: Title".
    severity: ERROR
    languages: [yaml]
    patterns:
      - pattern-inside: "rules: ..."
      - pattern-inside: "metadata: ..."
      - pattern: "cwe: ..."
      - pattern-not-regex: CWE-[\d]+:\s+\w
    metadata:
      category: best-practice
      technology:
        - semgrep


Example YAML file without metadata:

rules:
  - id: require-request
    message: >-
      If an attacker controls the x in require(x) then they can cause code to load that was not intended to run on the server.
    severity: LOW
    languages: [javascript, typescript]
    metadata:

Completed YAML file with metadata:

rules:
  - id: require-request
    message: >-
      If an attacker controls the x in require(x) then they can cause code to load that was not intended to run on the server.
    severity: LOW
    languages: [javascript, typescript]
    metadata:
      owasp: 
        - "A03:2021 - Injection"
      # ruleid: metadata-deepsemgrep
      deepsemgrep: true
      cwe: 
        - "CWE-706: Use of Incorrectly-Resolved Name or Reference"
      source-rule-url: https://nodesecroadmap.fyi/chapter-1/threat-UIR.html
      category: security
      likelihood: HIGH
      impact: HIGH
      confidence: HIGH
      subcategory: 
        - vuln
      technology:
        - express
      references:
        - https://github.com/google/node-sec-roadmap/blob/master/chapter-2/dynamism.md#dynamism-when-you-need-it
    patterns: 
  - id: require-request
    message: >-
      If an attacker controls the x in require(x) then they can cause code to load that was not intended to run on the server.
    severity: LOW
    languages: [javascript, typescript]
    metadata:
      owasp: 
        - "A03:2021 - Injection"
      # ruleid: metadata-deepsemgrep
      deepsemgrep: true
      cwe: 
        - "CWE-706: Use of Incorrectly-Resolved Name or Reference"
      source-rule-url: https://nodesecroadmap.fyi/chapter-1/threat-UIR.html
      category: security
      likelihood: HIGH
      impact: HIGH
      confidence: HIGH
      subcategory: 
        - vuln
      technology:
        - express
      references:
        - https://github.com/google/node-sec-roadmap/blob/master/chapter-2/dynamism.md#dynamism-when-you-need-it
    patterns: 


Example YAML file without metadata:

rules:
  - id: metadata-deepsemgrep
    patterns:
      - pattern-inside: |
          rules: 
            ...
      - pattern-inside: |
          metadata:

Completed YAML file with metadata:

rules:
  - id: metadata-deepsemgrep
    patterns:
      - pattern-inside: |
          rules: 
            ...
      - pattern-inside: |
          metadata: 
            ...
            $DEEPSEMGREP: true
            ...
      - focus-metavariable: $DEEPSEMGREP
      - metavariable-regex: 
          metavariable: $DEEPSEMGREP
          regex: ^(deepsemgrep)$
    message: >-
      We no longer support `deepsemgrep: true`, please use `interfile:true`
    fix-regex:
      regex: deepsemgrep
      replacement: interfile
    languages:
      - yaml
    severity: WARNING
    metadata:
      category: correctness
      technology:
        - semgrep
      references:
        - https://semgrep.dev/

Example YAML file without metadata:

rules:
  - id: require-request
    message: >-
      If an attacker controls the x in require(x) then they can cause code to load that was not intended to run on the server.
    severity: LOW
    languages: [javascript, typescript]
    metadata:

Completed YAML file with metadata:

rules:
  - id: require-request
    message: >-
      If an attacker controls the x in require(x) then they can cause code to load that was not intended to run on the server.
    severity: LOW
    languages: [javascript, typescript]
    metadata:
      owasp: "A03:2021 - Injection"
      cwe: "CWE-706: Use of Incorrectly-Resolved Name or Reference"
      source-rule-url: https://nodesecroadmap.fyi/chapter-1/threat-UIR.html
      category: security
      likelihood: lOW
      # ruleid: metadata-impact-incorrect-value
      impact: lOW
      technology:
        - express
      references:
        - https://github.com/google/node-sec-roadmap/blob/master/chapter-2/dynamism.md#dynamism-when-you-need-it
    patterns: 
  - id: require-request
    message: >-
      If an attacker controls the x in require(x) then they can cause code to load that was not intended to run on the server.
    severity: LOW
    languages: [javascript, typescript]
    metadata:
      owasp: "A03:2021 - Injection"
      cwe: "CWE-706: Use of Incorrectly-Resolved Name or Reference"
      source-rule-url: https://nodesecroadmap.fyi/chapter-1/threat-UIR.html
      category: security
      # ok: metadata-impact-incorrect-value
      impact: LOW
      likelihood: LOW
      technology:
        - express
      references:
        - https://github.com/google/node-sec-roadmap/blob/master/chapter-2/dynamism.md#dynamism-when-you-need-it
    patterns: 


Example YAML file without metadata:

rules:
  - id: metadata-impact-incorrect-value
    patterns:
      - pattern-inside: |
          rules: 
            ...
      - pattern-inside: |
          metadata:

Completed YAML file with metadata:

rules:
  - id: metadata-impact-incorrect-value
    patterns:
      - pattern-inside: |
          rules: 
            ...
      - pattern-inside: |
          metadata: 
            ...
            category: security
            ...
      - pattern: |
          impact: $VALUE
      - pattern-not: |
          impact: LOW
      - pattern-not: |
          impact: MEDIUM
      - pattern-not: |
          impact: HIGH
    message: >-
      Semgrep rule impact: $VALUE detected, but the value must be LOW,
      MEDIUM, or HIGH. For more information visit: 
      https://semgrep.dev/docs/contributing/contributing-to-semgrep-rules-repository/
    languages:
      - yaml
    severity: WARNING
    metadata:
      references:
        - https://semgrep.dev/docs/contributing/contributing-to-semgrep-rules-repository/
      category: correctness
      technology:
        - semgrep

Example YAML file without metadata:

rules:
  - id: require-request
    message: >-
      If an attacker controls the x in require(x) then they can cause code to load that was not intended to run on the server.
    severity: LOW
    languages: [javascript, typescript]
    # ok: metadata-impact
    metadata:

Completed YAML file with metadata:

rules:
  - id: require-request
    message: >-
      If an attacker controls the x in require(x) then they can cause code to load that was not intended to run on the server.
    severity: LOW
    languages: [javascript, typescript]
    # ok: metadata-impact
    metadata:
      owasp: "A03:2021 - Injection"
      cwe: "CWE-706: Use of Incorrectly-Resolved Name or Reference"
      source-rule-url: https://nodesecroadmap.fyi/chapter-1/threat-UIR.html
      category: security
      likelihood: LOW
      impact: LOW
      confidence: LOW
      technology:
        - express
      references:
        - https://github.com/google/node-sec-roadmap/blob/master/chapter-2/dynamism.md#dynamism-when-you-need-it
    patterns: 
  - id: require-request
    message: >-
      If an attacker controls the x in require(x) then they can cause code to load that was not intended to run on the server.
    severity: LOW
    languages: [javascript, typescript]
    # ruleid: metadata-impact
    metadata:
      owasp: "A03:2021 - Injection"
      cwe: "CWE-706: Use of Incorrectly-Resolved Name or Reference"
      source-rule-url: https://nodesecroadmap.fyi/chapter-1/threat-UIR.html
      category: security
      technology:
        - express
      references:
        - https://github.com/google/node-sec-roadmap/blob/master/chapter-2/dynamism.md#dynamism-when-you-need-it
    patterns: 


Example YAML file without metadata:

rules:
  - id: metadata-impact
    patterns:
      - pattern-inside: |
          rules: 
            ...
      - pattern-inside: |
          metadata:

Completed YAML file with metadata:

rules:
  - id: metadata-impact
    patterns:
      - pattern-inside: |
          rules: 
            ...
      - pattern-inside: |
          metadata: 
            ...
            category: security
            ...
      - pattern-not-inside: |
          metadata: 
            ...
            impact: $VALUE
    message: >-
      This Semgrep rule is missing a valid 'impact' field in the 'metadata'.
      which should be either LOW, MEDIUM, or HIGH. For more information visit 
      https://semgrep.dev/docs/contributing/contributing-to-semgrep-rules-repository/
    languages:
      - yaml
    severity: WARNING
    metadata:
      references:
        - https://semgrep.dev/docs/writing-rules/rule-syntax/#TODO
      category: correctness
      technology:
        - semgrep

Example YAML file without metadata:

rules:
  - id: id-request
    message: >-
      If an attacker controls the x in require(x) then they can cause code to load that was not intended to run on the server.
    severity: LOW
    languages: [javascript, typescript]
    metadata:

Completed YAML file with metadata:

rules:
  - id: id-request
    message: >-
      If an attacker controls the x in require(x) then they can cause code to load that was not intended to run on the server.
    severity: LOW
    languages: [javascript, typescript]
    metadata:
      owasp: "A03:2021 - Injection"
      cwe: "CWE-706: Use of Incorrectly-Resolved Name or Reference"
      source-rule-url: https://nodesecroadmap.fyi/chapter-1/threat-UIR.html
      category: security
      # ruleid: metadata-likelihood-incorrect-value
      likelihood: lOW
      impact: LOW
      technology:
        - express
      references:
        - https://github.com/google/node-sec-roadmap/blob/master/chapter-2/dynamism.md#dynamism-when-you-need-it
    patterns: 
  - id: ok-request
    message: >-
      If an attacker controls the x in require(x) then they can cause code to load that was not intended to run on the server.
    severity: LOW
    languages: [javascript, typescript]
    metadata:
      owasp: "A03:2021 - Injection"
      cwe: "CWE-706: Use of Incorrectly-Resolved Name or Reference"
      source-rule-url: https://nodesecroadmap.fyi/chapter-1/threat-UIR.html
      category: security
      # ok: metadata-likelihood-incorrect-value
      likelihood: LOW
      technology:
        - express
      references:
        - https://github.com/google/node-sec-roadmap/blob/master/chapter-2/dynamism.md#dynamism-when-you-need-it
    patterns: 


Example YAML file without metadata:

rules:
  - id: metadata-likelihood-incorrect-value
    patterns:
      - pattern-inside: |
          rules: 
            ...
      - pattern-inside: |
          metadata:

Completed YAML file with metadata:

rules:
  - id: metadata-likelihood-incorrect-value
    patterns:
      - pattern-inside: |
          rules: 
            ...
      - pattern-inside: |
          metadata: 
            ...
            category: security
            ...
      - pattern: |
          likelihood: $VALUE
      - pattern-not: |
          likelihood: LOW
      - pattern-not: |
          likelihood: MEDIUM
      - pattern-not: |
          likelihood: HIGH
    message: >-
      Semgrep rule likelihood: $VALUE detected, but the value must be LOW,
      MEDIUM, or HIGH. For more information visit: 
      https://semgrep.dev/docs/contributing/contributing-to-semgrep-rules-repository/
    languages:
      - yaml
    severity: WARNING
    metadata:
      references:
        - https://semgrep.dev/docs/contributing/contributing-to-semgrep-rules-repository/
      category: correctness
      technology:
        - semgrep

Example YAML file without metadata:

rules:
  - id: require-request
    message: >-
      If an attacker controls the x in require(x) then they can cause code to load that was not intended to run on the server.
    severity: LOW
    languages: [javascript, typescript]
    # ok: metadata-likelihood
    metadata:

Completed YAML file with metadata:

rules:
  - id: require-request
    message: >-
      If an attacker controls the x in require(x) then they can cause code to load that was not intended to run on the server.
    severity: LOW
    languages: [javascript, typescript]
    # ok: metadata-likelihood
    metadata:
      owasp: "A03:2021 - Injection"
      cwe: "CWE-706: Use of Incorrectly-Resolved Name or Reference"
      source-rule-url: https://nodesecroadmap.fyi/chapter-1/threat-UIR.html
      category: security
      likelihood: LOW
      impact: LOW
      confidence: LOW
      technology:
        - express
      references:
        - https://github.com/google/node-sec-roadmap/blob/master/chapter-2/dynamism.md#dynamism-when-you-need-it
    patterns: 
  - id: require-request
    message: >-
      If an attacker controls the x in require(x) then they can cause code to load that was not intended to run on the server.
    severity: LOW
    languages: [javascript, typescript]
    # ruleid: metadata-likelihood
    metadata:
      owasp: "A03:2021 - Injection"
      cwe: "CWE-706: Use of Incorrectly-Resolved Name or Reference"
      source-rule-url: https://nodesecroadmap.fyi/chapter-1/threat-UIR.html
      category: security
      technology:
        - express
      references:
        - https://github.com/google/node-sec-roadmap/blob/master/chapter-2/dynamism.md#dynamism-when-you-need-it
    patterns: 


Example YAML file without metadata:

rules:
  - id: metadata-likelihood
    patterns:
      - pattern-inside: |
          rules: 
            ...
      - pattern-inside: |
          metadata:

Completed YAML file with metadata:

rules:
  - id: metadata-likelihood
    patterns:
      - pattern-inside: |
          rules: 
            ...
      - pattern-inside: |
          metadata: 
            ...
            category: security
            ...
      - pattern-not-inside: |
          metadata: 
            ...
            likelihood: $VALUE
    message: >-
      This Semgrep rule is missing a valid 'likelihood' field in the 'metadata'.
      which should be either LOW, MEDIUM, or HIGH. For more information visit 
      https://semgrep.dev/docs/contributing/contributing-to-semgrep-rules-repository/
    languages:
      - yaml
    severity: WARNING
    metadata:
      references:
        - https://semgrep.dev/docs/contributing/contributing-to-semgrep-rules-repository/
      category: correctness
      technology:
        - semgrep

Example YAML file without metadata:

rules:
  - id: example-1
    message: Example
    severity: ERROR
    languages: [json, yaml]
    pattern: "..."
    metadata:

Completed YAML file with metadata:

rules:
  - id: example-1
    message: Example
    severity: ERROR
    languages: [json, yaml]
    pattern: "..."
    metadata:
      # ok: metadata-owasp
      owasp: "A1: Some Vulnerability"
  - id: example-2
    message: Example
    severity: ERROR
    languages: [json, yaml]
    pattern: "..."
    metadata:
      # ruleid: metadata-owasp
      owasp: "A11: Some Vulnerability"
  - id: example-3
    message: Example
    severity: ERROR
    languages: [json, yaml]
    pattern: "..."
    metadata:
      # ruleid: metadata-owasp
      owasp: a4
  - id: example-4
    message: Example
    severity: ERROR
    languages: [json, yaml]
    pattern: "..."
    metadata:
      # ruleid: metadata-owasp
      owasp: A5 Some Vulnerability
  - id: example-5
    message: Example
    severity: ERROR
    languages: [json, yaml]
    pattern: "..."
    metadata:
      # ok: metadata-owasp
      owasp:
        # ok: metadata-owasp
        - A05:2021 - Security Misconfiguration
        # ok: metadata-owasp
        - A06:2017 - Security Misconfiguration
  - id: example-6
    message: Example
    severity: ERROR
    languages: [json, yaml]
    pattern: "..."
    metadata:
      # ok: metadata-owasp
      owasp:
        # ruleid: metadata-owasp
        - A5:2021 - Security Misconfiguration
        # ruleid: metadata-owasp
        - A06:201789 - Security Misconfiguration


Example YAML file without metadata:

rules:
  - id: metadata-owasp
    message: >-
      The `owasp` tag in Semgrep rule metadata should start with the format "A00:YYYY",
      where A00 is the OWASP top ten number and YYYY is the OWASP top ten year.
    severity: ERROR
    languages: [json, yaml]
    patterns:
      - pattern-inside: "rules: ..."
      - pattern-inside: "metadata:

Completed YAML file with metadata:

rules:
  - id: metadata-owasp
    message: >-
      The `owasp` tag in Semgrep rule metadata should start with the format "A00:YYYY",
      where A00 is the OWASP top ten number and YYYY is the OWASP top ten year.
    severity: ERROR
    languages: [json, yaml]
    patterns:
      - pattern-inside: "rules: ..."
      - pattern-inside: "metadata: ..."
      - pattern-either:
          - patterns:
              - pattern: 'owasp: "..."'
              - pattern-not: 'owasp: "=~/^A(0?[1-9]|10): .+$/"'
          - patterns:
              - pattern-inside: "owasp: [...]"
              - pattern: '"$ANYTHING"'
              - pattern-not-regex: .*A[01][0-9]:[0-9]{4}\s+.*
              - pattern-not-regex: "owasp:"
    metadata:
      category: best-practice
      technology:
        - semgrep


Example YAML file without metadata:

rules:
  - id: example-1
    message: Example
    severity: ERROR
    languages: [json, yaml]
    pattern: "..."
    metadata:

Completed YAML file with metadata:

rules:
  - id: example-1
    message: Example
    severity: ERROR
    languages: [json, yaml]
    pattern: "..."
    metadata:
      # ok: metadata-references
      references:
        - https://google.com
  - id: example-2
    message: Example
    severity: ERROR
    languages: [json, yaml]
    pattern: "..."
    metadata:
      # ruleid: metadata-references
      references: https://google.com


Example YAML file without metadata:

rules:
  - id: metadata-references
    message: >-
      The references in rule metadata should always be a list, even if there's only one.
    severity: ERROR
    languages: [json, yaml]
    patterns:
      - pattern-inside: |
          rules: ...
      - pattern-inside: |
          metadata:

Completed YAML file with metadata:

rules:
  - id: metadata-references
    message: >-
      The references in rule metadata should always be a list, even if there's only one.
    severity: ERROR
    languages: [json, yaml]
    patterns:
      - pattern-inside: |
          rules: ...
      - pattern-inside: |
          metadata: ...
      - pattern: |
          references: ...
      - pattern-not: |
          references: [...]
    metadata:
      category: correctness
      technology:
        - semgrep


Example YAML file without metadata:

rules:
  - id: require-request
    message: >-
      If an attacker controls the x in require(x) then they can cause code to load that was not intended to run on the server.
    severity: LOW
    languages: [javascript, typescript]
    # ok: metadata-subcategory-incorrect-value
    metadata:

Completed YAML file with metadata:

rules:
  - id: require-request
    message: >-
      If an attacker controls the x in require(x) then they can cause code to load that was not intended to run on the server.
    severity: LOW
    languages: [javascript, typescript]
    # ok: metadata-subcategory-incorrect-value
    metadata:
      owasp: "A03:2021 - Injection"
      cwe: "CWE-706: Use of Incorrectly-Resolved Name or Reference"
      source-rule-url: https://nodesecroadmap.fyi/chapter-1/threat-UIR.html
      category: security
      likelihood: LOW
      impact: LOW
      confidence: LOW
      subcategory: 
        - audit
      technology:
        - express
      references:
        - https://github.com/google/node-sec-roadmap/blob/master/chapter-2/dynamism.md#dynamism-when-you-need-it
    patterns: 
  - id: require-request
    message: >-
      If an attacker controls the x in require(x) then they can cause code to load that was not intended to run on the server.
    severity: LOW
    languages: [javascript, typescript]
    metadata:
      owasp: "A03:2021 - Injection"
      cwe: "CWE-706: Use of Incorrectly-Resolved Name or Reference"
      source-rule-url: https://nodesecroadmap.fyi/chapter-1/threat-UIR.html
      category: security
      # ruleid: metadata-subcategory-incorrect-value
      subcategory: 
        - potato
      technology:
        - express
      references:
        - https://github.com/google/node-sec-roadmap/blob/master/chapter-2/dynamism.md#dynamism-when-you-need-it
    patterns: 


Example YAML file without metadata:

rules:
  - id: metadata-subcategory-incorrect-value
    patterns:
      - pattern-inside: |
          rules: 
            ...
      - pattern-inside: |
          metadata:

Completed YAML file with metadata:

rules:
  - id: metadata-subcategory-incorrect-value
    patterns:
      - pattern-inside: |
          rules: 
            ...
      - pattern-inside: |
          metadata: 
            ...
            category: security
            ...
      - pattern: |
          subcategory: 
            - $VALUE
      - pattern-not: |
          subcategory: 
            - vuln
      - pattern-not: |
          subcategory: 
            - audit
      - pattern-not: |
          subcategory: 
            - guardrail
    message: >-
      Semgrep rule likelihood: $VALUE detected, but the value must be vuln,
      audit, or guardrail. For more information visit:
      https://semgrep.dev/docs/contributing/contributing-to-semgrep-rules-repository/
    languages:
      - yaml
    severity: WARNING
    metadata:
      references:
        - https://semgrep.dev/docs/contributing/contributing-to-semgrep-rules-repository/
      category: correctness
      technology:
        - semgrep

Example YAML file without metadata:

rules:
  - id: require-request
    message: >-
      If an attacker controls the x in require(x) then they can cause code to load that was not intended to run on the server.
    severity: LOW
    languages: [javascript, typescript]
    # ok: metadata-subcategory
    metadata:

Completed YAML file with metadata:

rules:
  - id: require-request
    message: >-
      If an attacker controls the x in require(x) then they can cause code to load that was not intended to run on the server.
    severity: LOW
    languages: [javascript, typescript]
    # ok: metadata-subcategory
    metadata:
      owasp: "A03:2021 - Injection"
      cwe: "CWE-706: Use of Incorrectly-Resolved Name or Reference"
      source-rule-url: https://nodesecroadmap.fyi/chapter-1/threat-UIR.html
      category: security
      likelihood: LOW
      impact: LOW
      confidence: LOW
      subcategory: 
        - audit
      technology:
        - express
      references:
        - https://github.com/google/node-sec-roadmap/blob/master/chapter-2/dynamism.md#dynamism-when-you-need-it
    patterns: 
  - id: require-request
    message: >-
      If an attacker controls the x in require(x) then they can cause code to load that was not intended to run on the server.
    severity: LOW
    languages: [javascript, typescript]
    # ruleid: metadata-subcategory
    metadata:
      owasp: "A03:2021 - Injection"
      cwe: "CWE-706: Use of Incorrectly-Resolved Name or Reference"
      source-rule-url: https://nodesecroadmap.fyi/chapter-1/threat-UIR.html
      category: security
      technology:
        - express
      references:
        - https://github.com/google/node-sec-roadmap/blob/master/chapter-2/dynamism.md#dynamism-when-you-need-it
    patterns: 


Example YAML file without metadata:

rules:
  - id: metadata-subcategory
    patterns:
      - pattern-inside: |
          rules: 
            ...
      - pattern-inside: |
          metadata:

Completed YAML file with metadata:

rules:
  - id: metadata-subcategory
    patterns:
      - pattern-inside: |
          rules: 
            ...
      - pattern-inside: |
          metadata: 
            ...
            category: security
            ...
      - pattern-not-inside: |
          metadata: 
            ...
            subcategory: $VALUE
    message: >-
      This Semgrep rule is missing a valid 'subcategory' field in the 'metadata'.
      which should be either audit, vuln, or guardrail. For more information visit 
      https://semgrep.dev/docs/contributing/contributing-to-semgrep-rules-repository/
    languages:
      - yaml
    severity: WARNING
    metadata:
      references:
        - https://semgrep.dev/docs/contributing/contributing-to-semgrep-rules-repository/
      category: correctness
      technology:
        - semgrep

Example YAML file without metadata:

rules:
  # ruleid: metadata-technology
  - id: unchecked-subprocess-call
    patterns:
      - pattern-either:
          - pattern: |
              subprocess.call(...)
          - pattern: |
              subprocess.call(...)
      - pattern-not-inside: |
          $S = subprocess.call(...)
      - pattern-not-inside: |
          subprocess.call(...) == $X
    message: >-
      bad stuff
    severity: WARNING
    fix: subprocess.check_call(...)
    metadata:

Completed YAML file with metadata:

rules:
  # ruleid: metadata-technology
  - id: unchecked-subprocess-call
    patterns:
      - pattern-either:
          - pattern: |
              subprocess.call(...)
          - pattern: |
              subprocess.call(...)
      - pattern-not-inside: |
          $S = subprocess.call(...)
      - pattern-not-inside: |
          subprocess.call(...) == $X
    message: >-
      bad stuff
    severity: WARNING
    fix: subprocess.check_call(...)
    metadata:
      category: best-practice
  # ok: metadata-technology
  - id: subprocess-run
    patterns: subprocess.run(...)
    message: >-
      bad stuff
    severity: WARNING
    fix: subprocess.check_call(...)
    metadata:
      category: python
      technology:
        - semgrep
  # ok: metadata-technology
  - metadata:
      category: python
      technology:
        - semgrep
    id: subprocess-run-2
    patterns: subprocess.run(...)
    message: >-
      bad stuff
    severity: WARNING
    fix: subprocess.check_call(...)


Example YAML file without metadata:

rules:
  - id: metadata-technology
    message: >-
      This Semgrep rule is missing a 'technology' field in the 'metadata'.
      Consider adding a list of technologies based on the rule's associated
      library or framework, or another piece of relevant information.
    severity: INFO
    patterns:
      - pattern-inside: "rules: [..., $RULE, ...]"
      - pattern: |
          id: ...
          ...
      - pattern-not: |
          id: ...
          ...
          metadata:

Completed YAML file with metadata:

rules:
  - id: metadata-technology
    message: >-
      This Semgrep rule is missing a 'technology' field in the 'metadata'.
      Consider adding a list of technologies based on the rule's associated
      library or framework, or another piece of relevant information.
    severity: INFO
    patterns:
      - pattern-inside: "rules: [..., $RULE, ...]"
      - pattern: |
          id: ...
          ...
      - pattern-not: |
          id: ...
          ...
          metadata:
            ...
            technology:
              - ...
    languages: [yaml]
    metadata:
      category: best-practice
      technology:
        - semgrep


Example YAML file without metadata:

rules:
  - id: missing-language-field
    message: >-
      Please include a 'languages' field for your rule $RULEID!
    languages: [yaml]
    pattern-either:
      # non join mode
      - patterns:
          - pattern-inside: "rules: [..., $RULE, ...]"
          - pattern: "id: $RULEID"
          - pattern-not-inside: |
              - ...
                languages: ...
          - pattern-not-inside: |
              - ...
                mode: join
      # join mode
      - patterns:
          - pattern-inside: |
              rules: [ ..., $OUTER_RULE, ...]
          - pattern-inside: $OUTER_RULE
          - pattern-inside: |
              id: $OUTER_RULEID
              mode: join
              join:
                rules: [ ..., $INNER_RULE, ...]
                ...
              ...
          - pattern-inside: $INNER_RULE
          - pattern-not-inside: |
              - languages: ...
                ...
          - pattern: |
              id: $RULEID
    severity: WARNING
    metadata:

Completed YAML file with metadata:

rules:
  - id: missing-language-field
    message: >-
      Please include a 'languages' field for your rule $RULEID!
    languages: [yaml]
    pattern-either:
      # non join mode
      - patterns:
          - pattern-inside: "rules: [..., $RULE, ...]"
          - pattern: "id: $RULEID"
          - pattern-not-inside: |
              - ...
                languages: ...
          - pattern-not-inside: |
              - ...
                mode: join
      # join mode
      - patterns:
          - pattern-inside: |
              rules: [ ..., $OUTER_RULE, ...]
          - pattern-inside: $OUTER_RULE
          - pattern-inside: |
              id: $OUTER_RULEID
              mode: join
              join:
                rules: [ ..., $INNER_RULE, ...]
                ...
              ...
          - pattern-inside: $INNER_RULE
          - pattern-not-inside: |
              - languages: ...
                ...
          - pattern: |
              id: $RULEID
    severity: WARNING
    metadata:
      references:
        - https://semgrep.dev/docs/writing-rules/rule-syntax/#required
      category: correctness
      technology:
        - semgrep


Example YAML file without metadata:

rules:
  - id: missing-message-field
    message: >-
      This rule does not have a message. Semgrep requires that
      rules have a message. Include a message to explain what the rule does.
      Consider writing a message that explains why this is an issue and
      how to fix it.
    languages: [yaml]
    patterns:
      - pattern-inside: "rules: [..., $RULE, ...]"
      - pattern: "id: $RULEID"
      - pattern-not-inside: |
          - ...
            message: ...
      - pattern-not-inside: |
          - ...
            mode: extract
    severity: WARNING
    metadata:

Completed YAML file with metadata:

rules:
  - id: missing-message-field
    message: >-
      This rule does not have a message. Semgrep requires that
      rules have a message. Include a message to explain what the rule does.
      Consider writing a message that explains why this is an issue and
      how to fix it.
    languages: [yaml]
    patterns:
      - pattern-inside: "rules: [..., $RULE, ...]"
      - pattern: "id: $RULEID"
      - pattern-not-inside: |
          - ...
            message: ...
      - pattern-not-inside: |
          - ...
            mode: extract
    severity: WARNING
    metadata:
      category: correctness
      technology:
        - semgrep
      references:
      - https://semgrep.dev/docs/writing-rules/rule-syntax/

Example YAML file without metadata:

rules:
  - id: multi-line-message
    message: >-
      This rule has a multi-line message field, which may display poorly
      in a terminal. Consider ensuring it is on one line. For example,
      use `message: >-`, not `message: |`.
    languages: [yaml]
    patterns:
      - pattern-inside: "rules: [..., $RULE, ...]"
      - pattern: |
          message: "=~/[\\n\\r]/"
    severity: WARNING
    metadata:

Completed YAML file with metadata:

rules:
  - id: multi-line-message
    message: >-
      This rule has a multi-line message field, which may display poorly
      in a terminal. Consider ensuring it is on one line. For example,
      use `message: >-`, not `message: |`.
    languages: [yaml]
    patterns:
      - pattern-inside: "rules: [..., $RULE, ...]"
      - pattern: |
          message: "=~/[\\n\\r]/"
    severity: WARNING
    metadata:
      category: correctness
      technology:
        - semgrep
      references:
        - https://github.com/returntocorp/semgrep-rules/issues/1431


Example YAML file without metadata:

rules:
  - id: missing-deconstructed-value
    message: >-
      Looks like this value is deconstructing a const/var/let you need to use
      all three `const {...} =` `var {...} =` and `let {...} =` to provide
      accurate coverage consider adding the missing patterns in a
      `pattern-inside` for better coverage.
    languages:
      - yaml
    severity: WARNING
    metadata:

Completed YAML file with metadata:

rules:
  - id: missing-deconstructed-value
    message: >-
      Looks like this value is deconstructing a const/var/let you need to use
      all three `const {...} =` `var {...} =` and `let {...} =` to provide
      accurate coverage consider adding the missing patterns in a
      `pattern-inside` for better coverage.
    languages:
      - yaml
    severity: WARNING
    metadata:
      references:
        - https://semgrep.dev/docs/contributing/contributing-to-semgrep-rules-repository
      category: correctness
      technology:
        - semgrep
    patterns:
      - pattern-either:
          - patterns:
              - pattern-inside: |
                  rules: ...
              - pattern-not-inside: |
                  - pattern-either:
                      ...
              - pattern: |
                  - pattern-inside:
                      $VALUE
              - pattern-either:
                  - pattern-regex: const {.*}.*=
                  - pattern-regex: let {.*}.*=
                  - pattern-regex: var {.*}.*=
          - patterns:
              - patterns:
                  - pattern-inside: |
                      rules: ...
                  - pattern-inside: |
                      - pattern-either:
                          $VALUE
                  - focus-metavariable:
                      - $VALUE
                  - pattern-inside: |
                      - pattern-inside: 
                          $A
                  - metavariable-regex:
                      metavariable: $A
                      regex: .*\s.*(var|const|let)\s{.*}\s=
              - pattern-not:
                  patterns:
                    - pattern-inside: |
                        ...
                        - pattern-inside: 
                            $Z
                        ...
                        - pattern-inside: 
                            $B
                        ...            
                        - pattern-inside: 
                            $C
                        ...
                    - metavariable-regex:
                        metavariable: $Z
                        regex: .*\s.*(var|const|let).*{.*}
                    - metavariable-regex:
                        metavariable: $B
                        regex: .*\s.*(var|const|let).*{.*}
                    - metavariable-regex:
                        metavariable: $C
                        regex: .*\s.*(var|const|let).*{.*}


Example YAML file without metadata:

rules:
  - id: express-sandbox-code-injection
    message: >-
      Make sure that unverified user data can not reach `sandbox`.
    severity: ERROR
    languages: [javascript]
    metadata:

Completed YAML file with metadata:

rules:
  - id: express-sandbox-code-injection
    message: >-
      Make sure that unverified user data can not reach `sandbox`.
    severity: ERROR
    languages: [javascript]
    metadata:
      owasp: "A01:2017 - Injection"
      cwe: "CWE-94: Improper Control of Generation of Code ('Code Injection')"
    patterns:
      - pattern-either:
          - pattern-inside: |
              # ruleid: slow-pattern-general-func
              function ($REQ, $RES, ...) {
                  ...
              }
          # ruleid: slow-pattern-general-func
          - pattern-inside: function $FUNC($REQ, $RES, ...) {...}
          # ruleid: slow-pattern-general-func
          - pattern-inside: $X = function $FUNC($REQ, $RES, ...) {...}
      - pattern-either:
          - pattern: |
              $S = new $SANDBOX(...);
              ...
              $S.run(<... $REQ.$QUERY.$FOO ...>,...);


Example YAML file without metadata:

rules:
  - id: slow-pattern-general-func
    languages:
      - yaml
    message: >-
      Using patterns like `function (...) {...}` is too general it will probably slow down the rule performance.
    patterns:
      - pattern-either:
          - pattern-inside: |
              pattern-inside: $X
          - pattern-inside: |
              pattern-not-inside: $X
          - pattern-inside: |
              pattern: $X
          - pattern-inside: |
              pattern-not: $X
      - pattern-regex: function[^{]*{[\s\n]*\.\.\.[\s\n]*}
      - pattern-either:
          - pattern-inside: |
              languages: [...,"javascript",...]
              ...
          - pattern-inside: |
              languages: [...,"typescript",...]
              ...
    severity: WARNING
    metadata:

Completed YAML file with metadata:

rules:
  - id: slow-pattern-general-func
    languages:
      - yaml
    message: >-
      Using patterns like `function (...) {...}` is too general it will probably slow down the rule performance.
    patterns:
      - pattern-either:
          - pattern-inside: |
              pattern-inside: $X
          - pattern-inside: |
              pattern-not-inside: $X
          - pattern-inside: |
              pattern: $X
          - pattern-inside: |
              pattern-not: $X
      - pattern-regex: function[^{]*{[\s\n]*\.\.\.[\s\n]*}
      - pattern-either:
          - pattern-inside: |
              languages: [...,"javascript",...]
              ...
          - pattern-inside: |
              languages: [...,"typescript",...]
              ...
    severity: WARNING
    metadata:
      category: performance
      technology:
        - semgrep


Example YAML file without metadata:

rules:
  - id: express-sandbox-code-injection
    message: >-
      Make sure that unverified user data can not reach `sandbox`.
    severity: ERROR
    languages: [javascript]
    metadata:

Completed YAML file with metadata:

rules:
  - id: express-sandbox-code-injection
    message: >-
      Make sure that unverified user data can not reach `sandbox`.
    severity: ERROR
    languages: [javascript]
    metadata:
      owasp: "A01:2017 - Injection"
      cwe: "CWE-94: Improper Control of Generation of Code ('Code Injection')"
    patterns:
      - pattern-inside: |
          ...
          $SANDBOX = require('sandbox');
          ...
      - pattern-either:
          # ok: slow-pattern-general-property
          - pattern-inside: function ($REQ, $RES, ...) {...}
          # ok: slow-pattern-general-property
          - pattern-inside: function $FUNC($REQ, $RES, ...) {...}
          # ok: slow-pattern-general-property
          - pattern-inside: $X = function $FUNC($REQ, $RES, ...) {...}
          # ok: slow-pattern-general-property
          - pattern-inside: var $X = function $FUNC($REQ, $RES, ...) {...};
          # ruleid: slow-pattern-general-property
          - pattern-inside: $APP.$METHOD(..., function $FUNC($REQ, $RES, ...) {...})
      - pattern-either:
          # ruleid: slow-pattern-general-property
          - pattern: $S.run(<... $REQ.$QUERY.$FOO ...>,...);


Example YAML file without metadata:

rules:
  - id: slow-pattern-general-property
    languages:
      - yaml
    message: >-
      Using patterns like `$X.$Y` may be too general and may slow down the rule performance.
    patterns:
      - pattern-either:
          - pattern-inside: |
              pattern-inside: $X
          - pattern-inside: |
              pattern-not-inside: $X
          - pattern-inside: |
              pattern: $X
          - pattern-inside: |
              pattern-not: $X
      - pattern-regex: \$[A-Z]*\.\$[A-Z]*
    severity: WARNING
    metadata:

Completed YAML file with metadata:

rules:
  - id: slow-pattern-general-property
    languages:
      - yaml
    message: >-
      Using patterns like `$X.$Y` may be too general and may slow down the rule performance.
    patterns:
      - pattern-either:
          - pattern-inside: |
              pattern-inside: $X
          - pattern-inside: |
              pattern-not-inside: $X
          - pattern-inside: |
              pattern: $X
          - pattern-inside: |
              pattern-not: $X
      - pattern-regex: \$[A-Z]*\.\$[A-Z]*
    severity: WARNING
    metadata:
      category: performance
      technology:
        - semgrep


Example YAML file without metadata:

rules:
  - id: typescript.react.best-practice.react-props-in-state.react-props-in-state
    pattern-either:
      - patterns:
          # ok: slow-pattern-single-metavariable
          - pattern-inside: |
              class $CN extends React.Component {
                ...
              }
          - pattern-either:
              # ok: slow-pattern-single-metavariable
              - pattern: |
                  state = {$NAME: <... this.props.$PROP ...>}
              # ok: slow-pattern-single-metavariable
              - pattern: |
                  this.state = {$NAME: <... this.props.$PROP ...>}
      - patterns:
          # ok: slow-pattern-single-metavariable
          - pattern-inside: |
              function $FN({$PROP},...) {
                ...
              }
          # ok: slow-pattern-single-metavariable
          - pattern-inside: useState(...)
          # ruleid: slow-pattern-single-metavariable
          - pattern: $PROP
      - patterns:
          # ok: slow-pattern-single-metavariable
          - pattern-inside: |
              function $FN($PROP,...) {
                ...
              }
          # ok: slow-pattern-single-metavariable
          - pattern-inside: useState(...)
          # ruleid: slow-pattern-single-metavariable
          - pattern-not: $PROP
    message: >-
      It is a bad practice to stop the data flow in rendering by copying props into state.
    metadata:

Completed YAML file with metadata:

rules:
  - id: typescript.react.best-practice.react-props-in-state.react-props-in-state
    pattern-either:
      - patterns:
          # ok: slow-pattern-single-metavariable
          - pattern-inside: |
              class $CN extends React.Component {
                ...
              }
          - pattern-either:
              # ok: slow-pattern-single-metavariable
              - pattern: |
                  state = {$NAME: <... this.props.$PROP ...>}
              # ok: slow-pattern-single-metavariable
              - pattern: |
                  this.state = {$NAME: <... this.props.$PROP ...>}
      - patterns:
          # ok: slow-pattern-single-metavariable
          - pattern-inside: |
              function $FN({$PROP},...) {
                ...
              }
          # ok: slow-pattern-single-metavariable
          - pattern-inside: useState(...)
          # ruleid: slow-pattern-single-metavariable
          - pattern: $PROP
      - patterns:
          # ok: slow-pattern-single-metavariable
          - pattern-inside: |
              function $FN($PROP,...) {
                ...
              }
          # ok: slow-pattern-single-metavariable
          - pattern-inside: useState(...)
          # ruleid: slow-pattern-single-metavariable
          - pattern-not: $PROP
    message: >-
      It is a bad practice to stop the data flow in rendering by copying props into state.
    metadata:
      references:
        - https://overreacted.io/writing-resilient-components/#principle-1-dont-stop-the-data-flow
    languages:
      - typescript
      - javascript
    severity: WARNING


Example YAML file without metadata:

rules:
  - id: slow-pattern-single-metavariable
    languages:
      - yaml
    message: >-
      Using a single metavariable as a pattern drastically slows down the rule performance
      because it will match every expression in a file. Instead, try to match something
      specific such as a function name, or anchor on a statement that may occur above
      or below the pattern. The more specific you can be, the faster the pattern will run.
    patterns:
      - pattern-either:
          - pattern-inside: |
              pattern-inside: $PATTERN
          - pattern-inside: |
              pattern-not-inside: $PATTERN
          - pattern-inside: |
              pattern: $PATTERN
          - pattern-inside: |
              pattern-not: $PATTERN
      - metavariable-regex:
          metavariable: $PATTERN
          regex: \$[A-Z_]*
    severity: WARNING
    metadata:

Completed YAML file with metadata:

rules:
  - id: slow-pattern-single-metavariable
    languages:
      - yaml
    message: >-
      Using a single metavariable as a pattern drastically slows down the rule performance
      because it will match every expression in a file. Instead, try to match something
      specific such as a function name, or anchor on a statement that may occur above
      or below the pattern. The more specific you can be, the faster the pattern will run.
    patterns:
      - pattern-either:
          - pattern-inside: |
              pattern-inside: $PATTERN
          - pattern-inside: |
              pattern-not-inside: $PATTERN
          - pattern-inside: |
              pattern: $PATTERN
          - pattern-inside: |
              pattern-not: $PATTERN
      - metavariable-regex:
          metavariable: $PATTERN
          regex: \$[A-Z_]*
    severity: WARNING
    metadata:
      category: performance
      technology:
        - semgrep


Example YAML file without metadata:

rules:
  - id: slow-pattern-top-ellipsis
    languages:
      - yaml
    message: >-
      Using the ellipsis operator `...` at the top of the pattern drastically slows down the rule performance.
    patterns:
      - pattern-either:
          - pattern-inside: |
              pattern-inside: $X
          - pattern-inside: |
              pattern-not-inside: $X
          - pattern-inside: |
              pattern: $X
          - pattern-inside: |
              pattern-not: $X
      - pattern-regex: \|\s*\n\s*\.\.\.\s*\n[^\n]*\n\s*\.\.\.
    severity: WARNING
    metadata:

Completed YAML file with metadata:

rules:
  - id: slow-pattern-top-ellipsis
    languages:
      - yaml
    message: >-
      Using the ellipsis operator `...` at the top of the pattern drastically slows down the rule performance.
    patterns:
      - pattern-either:
          - pattern-inside: |
              pattern-inside: $X
          - pattern-inside: |
              pattern-not-inside: $X
          - pattern-inside: |
              pattern: $X
          - pattern-inside: |
              pattern-not: $X
      - pattern-regex: \|\s*\n\s*\.\.\.\s*\n[^\n]*\n\s*\.\.\.
    severity: WARNING
    metadata:
      category: performance
      technology:
        - semgrep


Example YAML file without metadata:

rules:
  - id: unnecessary-parent-operator
    message: Unnecessary parent operator. Remove one to fix.
    languages: [yaml]
    patterns:
      - pattern-inside: "rules: [..., $RULE, ...]"
      - pattern-either:
          - patterns:
              - pattern: |
                  pattern-either:
                  - $THING1
                  - ...
              - pattern-not: |
                  pattern-either:
                  - $THING1
                  - $THING2
                  - ...
          - patterns:
              - pattern: |
                  patterns:
                  - $THING1
                  - ...
              - pattern-not: |
                  patterns:
                  - $THING1
                  - $THING2
                  - ...
          - pattern: |
              pattern-either:
              - ...
              - pattern-either:
                - ...
    severity: WARNING
    metadata:

Completed YAML file with metadata:

rules:
  - id: unnecessary-parent-operator
    message: Unnecessary parent operator. Remove one to fix.
    languages: [yaml]
    patterns:
      - pattern-inside: "rules: [..., $RULE, ...]"
      - pattern-either:
          - patterns:
              - pattern: |
                  pattern-either:
                  - $THING1
                  - ...
              - pattern-not: |
                  pattern-either:
                  - $THING1
                  - $THING2
                  - ...
          - patterns:
              - pattern: |
                  patterns:
                  - $THING1
                  - ...
              - pattern-not: |
                  patterns:
                  - $THING1
                  - $THING2
                  - ...
          - pattern: |
              pattern-either:
              - ...
              - pattern-either:
                - ...
    severity: WARNING
    metadata:
      category: best-practice
      technology:
        - semgrep


Example YAML file without metadata:

rules:
  - id: unsatisfiable-rule
    message: >-
      You can not use 'pattern' $A and 'pattern-not' $A together; this will always be empty.
    severity: ERROR
    languages: [yaml]
    patterns:
      - pattern-inside: "patterns: [...]"
      - pattern-either:
          - patterns:
              - pattern-inside: |
                  - pattern: $A
                  ...
              - pattern: |
                  - pattern-not: $A
          - patterns:
              - pattern-inside: |
                  - pattern-not: $A
                  ...
              - pattern: |
                  - pattern: $A
    metadata:

Completed YAML file with metadata:

rules:
  - id: unsatisfiable-rule
    message: >-
      You can not use 'pattern' $A and 'pattern-not' $A together; this will always be empty.
    severity: ERROR
    languages: [yaml]
    patterns:
      - pattern-inside: "patterns: [...]"
      - pattern-either:
          - patterns:
              - pattern-inside: |
                  - pattern: $A
                  ...
              - pattern: |
                  - pattern-not: $A
          - patterns:
              - pattern-inside: |
                  - pattern-not: $A
                  ...
              - pattern: |
                  - pattern: $A
    metadata:
      category: correctness
      technology:
        - semgrep


Example YAML file without metadata:

rules:
- id: allow-privilege-escalation-no-securitycontext
  patterns:
  - pattern-inside: |
      containers:
        ...
  - pattern-inside: |
      - name: $CONTAINER
        ...
  - pattern: |
      image: ...
      ...
  - pattern-not: |
      image: ...
      ...
      securityContext:
        ...
  - focus-metavariable: $CONTAINER
  fix: |
    $CONTAINER
          securityContext:
            allowPrivilegeEscalation: false
  message: >-
    In Kubernetes, each pod runs in its own isolated environment with its own 
    set of security policies. However, certain container images may contain 
    `setuid` or `setgid` binaries that could allow an attacker to perform 
    privilege escalation and gain access to sensitive resources. To mitigate 
    this risk, it's recommended to add a `securityContext` to the container in 
    the pod, with the parameter `allowPrivilegeEscalation` set to `false`. 
    This will prevent the container from running any privileged processes and 
    limit the impact of any potential attacks. 
    By adding a `securityContext` to your Kubernetes pod, you can help to 
    ensure that your containerized applications are more secure and less 
    vulnerable to privilege escalation attacks.
  metadata:

Completed YAML file with metadata:

rules:
- id: allow-privilege-escalation-no-securitycontext
  patterns:
  - pattern-inside: |
      containers:
        ...
  - pattern-inside: |
      - name: $CONTAINER
        ...
  - pattern: |
      image: ...
      ...
  - pattern-not: |
      image: ...
      ...
      securityContext:
        ...
  - focus-metavariable: $CONTAINER
  fix: |
    $CONTAINER
          securityContext:
            allowPrivilegeEscalation: false
  message: >-
    In Kubernetes, each pod runs in its own isolated environment with its own 
    set of security policies. However, certain container images may contain 
    `setuid` or `setgid` binaries that could allow an attacker to perform 
    privilege escalation and gain access to sensitive resources. To mitigate 
    this risk, it's recommended to add a `securityContext` to the container in 
    the pod, with the parameter `allowPrivilegeEscalation` set to `false`. 
    This will prevent the container from running any privileged processes and 
    limit the impact of any potential attacks. 
    By adding a `securityContext` to your Kubernetes pod, you can help to 
    ensure that your containerized applications are more secure and less 
    vulnerable to privilege escalation attacks.
  metadata:
    cwe:
    - 'CWE-732: Incorrect Permission Assignment for Critical Resource'
    owasp:
    - A05:2021 - Security Misconfiguration
    - A06:2017 - Security Misconfiguration
    references:
    - https://kubernetes.io/docs/concepts/policy/pod-security-policy/#privilege-escalation
    - https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
    - https://www.kernel.org/doc/Documentation/prctl/no_new_privs.txt
    - https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html#rule-4-add-no-new-privileges-flag
    category: security
    technology:
    - kubernetes
    cwe2021-top25: true
    subcategory:
    - vuln
    likelihood: MEDIUM
    impact: MEDIUM
    confidence: MEDIUM
  languages: [yaml]
  severity: WARNING


Example YAML file without metadata:

rules:
- id: allow-privilege-escalation-true
  patterns:
  - pattern-inside: |
      containers:
        ...
  - pattern-inside: |
      - name: $CONTAINER
        ...
  - pattern-inside: |
      image: ...
      ...
  - pattern-inside: |
      securityContext:
        ...
  - pattern: |
      allowPrivilegeEscalation: $TRUE
  - metavariable-pattern:
      metavariable: $TRUE
      pattern: |
        true
  - focus-metavariable: $TRUE
  fix: |
    false
  message: >-
    In Kubernetes, each pod runs in its own isolated environment with its own 
    set of security policies. However, certain container images may contain 
    `setuid` or `setgid` binaries that could allow an attacker to perform 
    privilege escalation and gain access to sensitive resources. To mitigate 
    this risk, it's recommended to add a `securityContext` to the container in 
    the pod, with the parameter `allowPrivilegeEscalation` set to `false`. 
    This will prevent the container from running any privileged processes and 
    limit the impact of any potential attacks. 
    In the container `$CONTAINER` this parameter is set to `true` which makes
    this container much more vulnerable to privelege escalation attacks.
  metadata:

Completed YAML file with metadata:

rules:
- id: allow-privilege-escalation-true
  patterns:
  - pattern-inside: |
      containers:
        ...
  - pattern-inside: |
      - name: $CONTAINER
        ...
  - pattern-inside: |
      image: ...
      ...
  - pattern-inside: |
      securityContext:
        ...
  - pattern: |
      allowPrivilegeEscalation: $TRUE
  - metavariable-pattern:
      metavariable: $TRUE
      pattern: |
        true
  - focus-metavariable: $TRUE
  fix: |
    false
  message: >-
    In Kubernetes, each pod runs in its own isolated environment with its own 
    set of security policies. However, certain container images may contain 
    `setuid` or `setgid` binaries that could allow an attacker to perform 
    privilege escalation and gain access to sensitive resources. To mitigate 
    this risk, it's recommended to add a `securityContext` to the container in 
    the pod, with the parameter `allowPrivilegeEscalation` set to `false`. 
    This will prevent the container from running any privileged processes and 
    limit the impact of any potential attacks. 
    In the container `$CONTAINER` this parameter is set to `true` which makes
    this container much more vulnerable to privelege escalation attacks.
  metadata:
    cwe:
    - 'CWE-732: Incorrect Permission Assignment for Critical Resource'
    owasp:
    - A05:2021 - Security Misconfiguration
    - A06:2017 - Security Misconfiguration
    references:
    - https://kubernetes.io/docs/concepts/policy/pod-security-policy/#privilege-escalation
    - https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
    - https://www.kernel.org/doc/Documentation/prctl/no_new_privs.txt
    - https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html#rule-4-add-no-new-privileges-flag
    category: security
    technology:
    - kubernetes
    cwe2021-top25: true
    subcategory:
    - vuln
    likelihood: MEDIUM
    impact: MEDIUM
    confidence: MEDIUM
  languages: [yaml]
  severity: WARNING


Example YAML file without metadata:

rules:
- id: allow-privilege-escalation
  patterns:
  - pattern-inside: |
      containers:
        ...
  - pattern-inside: |
      - name: $CONTAINER
        ...
  - pattern: |
      image: ...
      ...
  - pattern-inside: |
      image: ...
      ...
      $SC:
        ...
  - metavariable-regex:
      metavariable: $SC
      regex: ^(securityContext)$
  - pattern-not-inside: |
      image: ...
      ...
      securityContext:
        ...
        allowPrivilegeEscalation: $VAL
  - focus-metavariable: $SC
  fix: |
    securityContext:
            allowPrivilegeEscalation: false #
  message: >-
    In Kubernetes, each pod runs in its own isolated environment with its own 
    set of security policies. However, certain container images may contain 
    `setuid` or `setgid` binaries that could allow an attacker to perform 
    privilege escalation and gain access to sensitive resources. To mitigate 
    this risk, it's recommended to add a `securityContext` to the container in 
    the pod, with the parameter `allowPrivilegeEscalation` set to `false`. 
    This will prevent the container from running any privileged processes and 
    limit the impact of any potential attacks. 
    By adding the `allowPrivilegeEscalation` parameter to your the 
    `securityContext`, you can help to 
    ensure that your containerized applications are more secure and less 
    vulnerable to privilege escalation attacks.
  metadata:

Completed YAML file with metadata:

rules:
- id: allow-privilege-escalation
  patterns:
  - pattern-inside: |
      containers:
        ...
  - pattern-inside: |
      - name: $CONTAINER
        ...
  - pattern: |
      image: ...
      ...
  - pattern-inside: |
      image: ...
      ...
      $SC:
        ...
  - metavariable-regex:
      metavariable: $SC
      regex: ^(securityContext)$
  - pattern-not-inside: |
      image: ...
      ...
      securityContext:
        ...
        allowPrivilegeEscalation: $VAL
  - focus-metavariable: $SC
  fix: |
    securityContext:
            allowPrivilegeEscalation: false #
  message: >-
    In Kubernetes, each pod runs in its own isolated environment with its own 
    set of security policies. However, certain container images may contain 
    `setuid` or `setgid` binaries that could allow an attacker to perform 
    privilege escalation and gain access to sensitive resources. To mitigate 
    this risk, it's recommended to add a `securityContext` to the container in 
    the pod, with the parameter `allowPrivilegeEscalation` set to `false`. 
    This will prevent the container from running any privileged processes and 
    limit the impact of any potential attacks. 
    By adding the `allowPrivilegeEscalation` parameter to your the 
    `securityContext`, you can help to 
    ensure that your containerized applications are more secure and less 
    vulnerable to privilege escalation attacks.
  metadata:
    cwe:
    - 'CWE-732: Incorrect Permission Assignment for Critical Resource'
    owasp:
    - A05:2021 - Security Misconfiguration
    - A06:2017 - Security Misconfiguration
    references:
    - https://kubernetes.io/docs/concepts/policy/pod-security-policy/#privilege-escalation
    - https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
    - https://www.kernel.org/doc/Documentation/prctl/no_new_privs.txt
    - https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html#rule-4-add-no-new-privileges-flag
    category: security
    technology:
    - kubernetes
    cwe2021-top25: true
    subcategory:
    - vuln
    likelihood: MEDIUM
    impact: MEDIUM
    confidence: MEDIUM
  languages: [yaml]
  severity: WARNING


Example YAML file without metadata:

apiVersion: v1
kind: Pod
metadata:

Completed YAML file with metadata:

apiVersion: v1
kind: Pod
metadata:
  name: test-pd
spec:
  containers:
    - image: gcr.io/google_containers/test-webserver
      name: test-container
      volumeMounts:
        - mountPath: /var/run/docker.sock
          name: docker-sock-volume
  volumes:
    - name: docker-sock-volume
      # ruleid: exposing-docker-socket-hostpath
      hostPath:
        type: File
        path: /var/run/docker.sock


Example YAML file without metadata:

rules:
- id: exposing-docker-socket-hostpath
  patterns:
  - pattern-inside: |
      volumes:
        ...
  - pattern: |
      hostPath:
        ...
        path: /var/run/docker.sock
  message: >-
    Exposing host's Docker socket to containers via a volume. The owner of this
    socket is root. Giving someone access to it is equivalent to giving
    unrestricted root access to your host. Remove 'docker.sock' from hostpath to
    prevent this.
  metadata:

Completed YAML file with metadata:

rules:
- id: exposing-docker-socket-hostpath
  patterns:
  - pattern-inside: |
      volumes:
        ...
  - pattern: |
      hostPath:
        ...
        path: /var/run/docker.sock
  message: >-
    Exposing host's Docker socket to containers via a volume. The owner of this
    socket is root. Giving someone access to it is equivalent to giving
    unrestricted root access to your host. Remove 'docker.sock' from hostpath to
    prevent this.
  metadata:
    cwe:
    - 'CWE-250: Execution with Unnecessary Privileges'
    references:
    - https://kubernetes.io/docs/concepts/storage/volumes/#hostpath
    - https://kubernetes.io/docs/concepts/policy/pod-security-policy/#volumes-and-file-systems
    - https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
    - https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html#rule-1-do-not-expose-the-docker-daemon-socket-even-to-the-containers
    category: security
    technology:
    - kubernetes
    subcategory:
    - vuln
    likelihood: LOW
    impact: HIGH
    confidence: MEDIUM
  languages: [yaml]
  severity: WARNING


Example YAML file without metadata:

apiVersion: v1
kind: Pod
metadata:

Completed YAML file with metadata:

apiVersion: v1
kind: Pod
metadata:
  name: view-pid
spec:
  # ruleid: hostipc-pod
  hostIPC: true
  containers:
    - name: nginx
      image: nginx


Example YAML file without metadata:

rules:
- id: hostipc-pod
  patterns:
  - pattern-inside: |
      spec:
        ...
  - pattern: |
      hostIPC: true
  message: >-
    Pod is sharing the host IPC namespace. This allows container processes
    to communicate with processes on the host which reduces isolation and
    bypasses container protection models. Remove the 'hostIPC' key to disable
    this functionality.
  metadata:

Completed YAML file with metadata:

rules:
- id: hostipc-pod
  patterns:
  - pattern-inside: |
      spec:
        ...
  - pattern: |
      hostIPC: true
  message: >-
    Pod is sharing the host IPC namespace. This allows container processes
    to communicate with processes on the host which reduces isolation and
    bypasses container protection models. Remove the 'hostIPC' key to disable
    this functionality.
  metadata:
    cwe:
    - 'CWE-693: Protection Mechanism Failure'
    references:
    - https://kubernetes.io/docs/concepts/policy/pod-security-policy/#host-namespaces
    category: security
    technology:
    - kubernetes
    subcategory:
    - audit
    likelihood: LOW
    impact: MEDIUM
    confidence: LOW
  languages: [yaml]
  severity: WARNING


Example YAML file without metadata:

apiVersion: v1
kind: Pod
metadata:

Completed YAML file with metadata:

apiVersion: v1
kind: Pod
metadata:
  name: view-pid
spec:
  # ruleid: hostnetwork-pod
  hostNetwork: true
  containers:
    - name: nginx
      image: nginx


Example YAML file without metadata:

rules:
- id: hostnetwork-pod
  patterns:
  - pattern-inside: |
      spec:
        ...
  - pattern: |
      hostNetwork: true
  message: >-
    Pod may use the node network namespace. This gives the pod access to the
    loopback device, services listening on localhost, and could be used to
    snoop on network activity of other pods on the same node. Remove the
    'hostNetwork' key to disable this functionality.
  metadata:

Completed YAML file with metadata:

rules:
- id: hostnetwork-pod
  patterns:
  - pattern-inside: |
      spec:
        ...
  - pattern: |
      hostNetwork: true
  message: >-
    Pod may use the node network namespace. This gives the pod access to the
    loopback device, services listening on localhost, and could be used to
    snoop on network activity of other pods on the same node. Remove the
    'hostNetwork' key to disable this functionality.
  metadata:
    cwe:
    - 'CWE-406: Insufficient Control of Network Message Volume (Network Amplification)'
    references:
    - https://kubernetes.io/docs/concepts/policy/pod-security-policy/#host-namespaces
    category: security
    technology:
    - kubernetes
    subcategory:
    - audit
    likelihood: LOW
    impact: MEDIUM
    confidence: LOW
  languages: [yaml]
  severity: WARNING


Example YAML file without metadata:

apiVersion: v1
kind: Pod
metadata:

Completed YAML file with metadata:

apiVersion: v1
kind: Pod
metadata:
  name: view-pid
spec:
  # ruleid: hostpid-pod
  hostPID: true
  containers:
    - name: nginx
      image: nginx


Example YAML file without metadata:

rules:
- id: hostpid-pod
  patterns:
  - pattern-inside: |
      spec:
        ...
  - pattern: |
      hostPID: true
  message: >-
    Pod is sharing the host process ID namespace. When paired with ptrace
    this can be used to escalate privileges outside of the container. Remove
    the 'hostPID' key to disable this functionality.
  metadata:

Completed YAML file with metadata:

rules:
- id: hostpid-pod
  patterns:
  - pattern-inside: |
      spec:
        ...
  - pattern: |
      hostPID: true
  message: >-
    Pod is sharing the host process ID namespace. When paired with ptrace
    this can be used to escalate privileges outside of the container. Remove
    the 'hostPID' key to disable this functionality.
  metadata:
    cwe:
    - 'CWE-269: Improper Privilege Management'
    references:
    - https://kubernetes.io/docs/concepts/policy/pod-security-policy/#host-namespaces
    category: security
    technology:
    - kubernetes
    owasp:
    - A04:2021 - Insecure Design
    subcategory:
    - audit
    likelihood: LOW
    impact: MEDIUM
    confidence: LOW
  languages: [yaml]
  severity: WARNING


Example YAML file without metadata:

rules:
- id: privileged-container
  pattern-either:
  - patterns:
    - pattern-inside: |
        containers:
          ...
    - pattern: |
        image: ...
        ...
        securityContext:
          ...
          privileged: true
  - patterns:
    - pattern-inside: |
        spec:
          ...
    - pattern-not-inside: |
        image: ...
        ...
    - pattern: |
        privileged: true
  message: >-
    Container or pod is running in privileged mode. This grants the
    container the equivalent of root capabilities on the host machine. This
    can lead to container escapes, privilege escalation, and other security
    concerns. Remove the 'privileged' key to disable this capability.
  metadata:

Completed YAML file with metadata:

rules:
- id: privileged-container
  pattern-either:
  - patterns:
    - pattern-inside: |
        containers:
          ...
    - pattern: |
        image: ...
        ...
        securityContext:
          ...
          privileged: true
  - patterns:
    - pattern-inside: |
        spec:
          ...
    - pattern-not-inside: |
        image: ...
        ...
    - pattern: |
        privileged: true
  message: >-
    Container or pod is running in privileged mode. This grants the
    container the equivalent of root capabilities on the host machine. This
    can lead to container escapes, privilege escalation, and other security
    concerns. Remove the 'privileged' key to disable this capability.
  metadata:
    cwe:
    - 'CWE-250: Execution with Unnecessary Privileges'
    references:
    - https://kubernetes.io/docs/concepts/policy/pod-security-policy/#privileged
    - https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
    - https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html
    category: security
    technology:
    - kubernetes
    subcategory:
    - vuln
    likelihood: MEDIUM
    impact: MEDIUM
    confidence: MEDIUM
  languages: [yaml]
  severity: WARNING


Example YAML file without metadata:

rules:
- id: run-as-non-root-container-level-missing-security-context
  patterns:
  - pattern-inside: |
      spec:
        ...
        containers:
          ...
        ...
  # No runAsNonRoot in Security Context at pod level
  - pattern-not-inside: |
      spec:
        ...
        securityContext:
          ...
          runAsNonRoot: $VAL
        ...
  # Containers defined
  - pattern-inside: |
      spec:
        ...
        containers:
          ...
  # At least one container in this pod has defined runAsNonRoot
  # So a decision is made to secure at container level
  - pattern-inside: |
      spec:
        ...
        containers:
          ...
          - name: $NAME
            image: ...
            ...
            securityContext:
              ...
              runAsNonRoot: $VALUE
  # Capture container image
  - pattern: |
          - name: $CONTAINER
            image: $IMAGE
            ...
  # But missing securityContext
  - pattern-not: |
          - name: $CONTAINER
            image: $IMAGE
            ...
            securityContext:
              ...
  - focus-metavariable: $IMAGE
  fix: |
    $IMAGE
          securityContext:
            runAsNonRoot: true
  message: >-
    When running containers in Kubernetes, it's important to ensure that they 
    are properly secured to prevent privilege escalation attacks. 
    One potential vulnerability is when a container is allowed to run 
    applications as the root user, which could allow an attacker to gain 
    access to sensitive resources. To mitigate this risk, it's recommended to 
    add a `securityContext` to the container, with the parameter `runAsNonRoot` 
    set to `true`. This will ensure that the container runs as a non-root user, 
    limiting the damage that could be caused by any potential attacks. By 
    adding a `securityContext` to the container in your Kubernetes pod, you can 
    help to ensure that your containerized applications are more secure and 
    less vulnerable to privilege escalation attacks.
  metadata:

Completed YAML file with metadata:

rules:
- id: run-as-non-root-container-level-missing-security-context
  patterns:
  - pattern-inside: |
      spec:
        ...
        containers:
          ...
        ...
  # No runAsNonRoot in Security Context at pod level
  - pattern-not-inside: |
      spec:
        ...
        securityContext:
          ...
          runAsNonRoot: $VAL
        ...
  # Containers defined
  - pattern-inside: |
      spec:
        ...
        containers:
          ...
  # At least one container in this pod has defined runAsNonRoot
  # So a decision is made to secure at container level
  - pattern-inside: |
      spec:
        ...
        containers:
          ...
          - name: $NAME
            image: ...
            ...
            securityContext:
              ...
              runAsNonRoot: $VALUE
  # Capture container image
  - pattern: |
          - name: $CONTAINER
            image: $IMAGE
            ...
  # But missing securityContext
  - pattern-not: |
          - name: $CONTAINER
            image: $IMAGE
            ...
            securityContext:
              ...
  - focus-metavariable: $IMAGE
  fix: |
    $IMAGE
          securityContext:
            runAsNonRoot: true
  message: >-
    When running containers in Kubernetes, it's important to ensure that they 
    are properly secured to prevent privilege escalation attacks. 
    One potential vulnerability is when a container is allowed to run 
    applications as the root user, which could allow an attacker to gain 
    access to sensitive resources. To mitigate this risk, it's recommended to 
    add a `securityContext` to the container, with the parameter `runAsNonRoot` 
    set to `true`. This will ensure that the container runs as a non-root user, 
    limiting the damage that could be caused by any potential attacks. By 
    adding a `securityContext` to the container in your Kubernetes pod, you can 
    help to ensure that your containerized applications are more secure and 
    less vulnerable to privilege escalation attacks.
  metadata:
    references:
    - https://kubernetes.io/blog/2016/08/security-best-practices-kubernetes-deployment/
    - https://kubernetes.io/docs/concepts/policy/pod-security-policy/
    - https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html#rule-2-set-a-user
    category: security
    cwe:
    - 'CWE-250: Execution with Unnecessary Privileges'
    owasp:
    - A05:2021 - Security Misconfiguration
    - A06:2017 - Security Misconfiguration
    technology:
    - kubernetes
    subcategory:
    - audit
    likelihood: LOW
    impact: LOW
    confidence: LOW
  languages:
  - yaml
  severity: INFO


Example YAML file without metadata:

rules:
- id: run-as-non-root-container-level
  patterns:
  - pattern-inside: |
      spec:
        ...
        containers:
          ...
        ...
  # No runAsNonRoot in Security Context at pod level
  - pattern-not-inside: |
      spec:
        ...
        securityContext:
          ...
          runAsNonRoot: $VAL
        ...
  # Containers defined
  - pattern-inside: |
      spec:
        ...
        containers:
          ...
  # At least one container in this pod has defined runAsNonRoot
  # So a decision is made to secure at container level
  - pattern-inside: |
      spec:
        ...
        containers:
          ...
          - name: $NAME
            image: ...
            ...
            securityContext:
              ...
              runAsNonRoot: $VALUE
  # Capture container security Context
  - pattern: |
          - name: $CONTAINER
            image: ...
            ...
            $SC:
              ...
  - metavariable-regex:
      metavariable: $SC
      regex: ^(securityContext)$
  # But missing runAsNonRoot
  - pattern-not: |
          - name: $CONTAINER
            image: ...
            ...
            securityContext:
              ...
              runAsNonRoot: $VALUE
  - focus-metavariable: $SC
  fix: |
    $SC:
            runAsNonRoot: true #
  message: >-
    When running containers in Kubernetes, it's important to ensure that they 
    are properly secured to prevent privilege escalation attacks. 
    One potential vulnerability is when a container is allowed to run 
    applications as the root user, which could allow an attacker to gain 
    access to sensitive resources. To mitigate this risk, it's recommended to 
    add a `securityContext` to the container, with the parameter `runAsNonRoot` 
    set to `true`. This will ensure that the container runs as a non-root user, 
    limiting the damage that could be caused by any potential attacks. By 
    adding a `securityContext` to the container in your Kubernetes pod, you can 
    help to ensure that your containerized applications are more secure and 
    less vulnerable to privilege escalation attacks.
  metadata:

Completed YAML file with metadata:

rules:
- id: run-as-non-root-container-level
  patterns:
  - pattern-inside: |
      spec:
        ...
        containers:
          ...
        ...
  # No runAsNonRoot in Security Context at pod level
  - pattern-not-inside: |
      spec:
        ...
        securityContext:
          ...
          runAsNonRoot: $VAL
        ...
  # Containers defined
  - pattern-inside: |
      spec:
        ...
        containers:
          ...
  # At least one container in this pod has defined runAsNonRoot
  # So a decision is made to secure at container level
  - pattern-inside: |
      spec:
        ...
        containers:
          ...
          - name: $NAME
            image: ...
            ...
            securityContext:
              ...
              runAsNonRoot: $VALUE
  # Capture container security Context
  - pattern: |
          - name: $CONTAINER
            image: ...
            ...
            $SC:
              ...
  - metavariable-regex:
      metavariable: $SC
      regex: ^(securityContext)$
  # But missing runAsNonRoot
  - pattern-not: |
          - name: $CONTAINER
            image: ...
            ...
            securityContext:
              ...
              runAsNonRoot: $VALUE
  - focus-metavariable: $SC
  fix: |
    $SC:
            runAsNonRoot: true #
  message: >-
    When running containers in Kubernetes, it's important to ensure that they 
    are properly secured to prevent privilege escalation attacks. 
    One potential vulnerability is when a container is allowed to run 
    applications as the root user, which could allow an attacker to gain 
    access to sensitive resources. To mitigate this risk, it's recommended to 
    add a `securityContext` to the container, with the parameter `runAsNonRoot` 
    set to `true`. This will ensure that the container runs as a non-root user, 
    limiting the damage that could be caused by any potential attacks. By 
    adding a `securityContext` to the container in your Kubernetes pod, you can 
    help to ensure that your containerized applications are more secure and 
    less vulnerable to privilege escalation attacks.
  metadata:
    references:
    - https://kubernetes.io/blog/2016/08/security-best-practices-kubernetes-deployment/
    - https://kubernetes.io/docs/concepts/policy/pod-security-policy/
    - https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html#rule-2-set-a-user
    category: security
    cwe:
    - 'CWE-250: Execution with Unnecessary Privileges'
    owasp:
    - A05:2021 - Security Misconfiguration
    - A06:2017 - Security Misconfiguration
    technology:
    - kubernetes
    subcategory:
    - audit
    likelihood: LOW
    impact: LOW
    confidence: LOW
  languages:
  - yaml
  severity: INFO


Example YAML file without metadata:

rules:
- id: run-as-non-root-security-context-pod-level
  patterns:
  # Pod Security Context
  - pattern-inside: |
      spec:
        ...
        $SC:
          ...
        ...
  - metavariable-regex:
      metavariable: $SC
      regex: ^(securityContext)$
  # Pod Security Context does not contain runAsNonRoot
  - pattern-not-inside: |
      spec:
        ...
        securityContext:
          runAsNonRoot: $VAL
        ...
  # Containers defined
  - pattern-inside: |
      $SPEC:
        ...
        containers:
          ...
  # Security Context of all containers in this pod are missing runAsNonRoot
  # So no decision is made to secure at container level in other containers
  - pattern-not-inside: |
      $SPEC:
        ...
        containers:
          ...
          - name: $NAME
            image: ...
            ...
            securityContext:
              ...
              runAsNonRoot: $VALUE
  - focus-metavariable: $SC
  fix: |
    $SC:
        runAsNonRoot: true #
  message: >-
    When running containers in Kubernetes, it's important to ensure that they 
    are properly secured to prevent privilege escalation attacks. 
    One potential vulnerability is when a container is allowed to run 
    applications as the root user, which could allow an attacker to gain 
    access to sensitive resources. To mitigate this risk, it's recommended to 
    add a `securityContext` to the container, with the parameter `runAsNonRoot` 
    set to `true`. This will ensure that the container runs as a non-root user, 
    limiting the damage that could be caused by any potential attacks. By 
    adding a `securityContext` to the container in your Kubernetes pod, you can 
    help to ensure that your containerized applications are more secure and 
    less vulnerable to privilege escalation attacks.
  metadata:

Completed YAML file with metadata:

rules:
- id: run-as-non-root-security-context-pod-level
  patterns:
  # Pod Security Context
  - pattern-inside: |
      spec:
        ...
        $SC:
          ...
        ...
  - metavariable-regex:
      metavariable: $SC
      regex: ^(securityContext)$
  # Pod Security Context does not contain runAsNonRoot
  - pattern-not-inside: |
      spec:
        ...
        securityContext:
          runAsNonRoot: $VAL
        ...
  # Containers defined
  - pattern-inside: |
      $SPEC:
        ...
        containers:
          ...
  # Security Context of all containers in this pod are missing runAsNonRoot
  # So no decision is made to secure at container level in other containers
  - pattern-not-inside: |
      $SPEC:
        ...
        containers:
          ...
          - name: $NAME
            image: ...
            ...
            securityContext:
              ...
              runAsNonRoot: $VALUE
  - focus-metavariable: $SC
  fix: |
    $SC:
        runAsNonRoot: true #
  message: >-
    When running containers in Kubernetes, it's important to ensure that they 
    are properly secured to prevent privilege escalation attacks. 
    One potential vulnerability is when a container is allowed to run 
    applications as the root user, which could allow an attacker to gain 
    access to sensitive resources. To mitigate this risk, it's recommended to 
    add a `securityContext` to the container, with the parameter `runAsNonRoot` 
    set to `true`. This will ensure that the container runs as a non-root user, 
    limiting the damage that could be caused by any potential attacks. By 
    adding a `securityContext` to the container in your Kubernetes pod, you can 
    help to ensure that your containerized applications are more secure and 
    less vulnerable to privilege escalation attacks.
  metadata:
    references:
    - https://kubernetes.io/blog/2016/08/security-best-practices-kubernetes-deployment/
    - https://kubernetes.io/docs/concepts/policy/pod-security-policy/
    - https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html#rule-2-set-a-user
    category: security
    cwe:
    - 'CWE-250: Execution with Unnecessary Privileges'
    owasp:
    - A05:2021 - Security Misconfiguration
    - A06:2017 - Security Misconfiguration
    technology:
    - kubernetes
    subcategory:
    - audit
    likelihood: LOW
    impact: LOW
    confidence: LOW
  languages:
  - yaml
  severity: INFO


Example YAML file without metadata:

rules:
- id: run-as-non-root-unsafe-value
  patterns:
  - pattern-either:
      # Pod Security Context
      - pattern: |
          spec:
            ...
            securityContext:
              ...
              runAsNonRoot: $VALUE
      # Container Security Context
      - patterns:
          - pattern-inside: |
              containers:
                ...
          - pattern: |
              image: ...
              ...
              securityContext:
                ...
                runAsNonRoot: $VALUE
  - metavariable-pattern:
      metavariable: $VALUE
      pattern: |
        false
  - focus-metavariable: $VALUE
  fix: |
    true
  message: >-
    When running containers in Kubernetes, it's important to ensure that they 
    are properly secured to prevent privilege escalation attacks. 
    One potential vulnerability is when a container is allowed to run 
    applications as the root user, which could allow an attacker to gain 
    access to sensitive resources. To mitigate this risk, it's recommended to 
    add a `securityContext` to the container, with the parameter `runAsNonRoot` 
    set to `true`. This will ensure that the container runs as a non-root user, 
    limiting the damage that could be caused by any potential attacks. By 
    adding a `securityContext` to the container in your Kubernetes pod, you can 
    help to ensure that your containerized applications are more secure and 
    less vulnerable to privilege escalation attacks.
  metadata:

Completed YAML file with metadata:

rules:
- id: run-as-non-root-unsafe-value
  patterns:
  - pattern-either:
      # Pod Security Context
      - pattern: |
          spec:
            ...
            securityContext:
              ...
              runAsNonRoot: $VALUE
      # Container Security Context
      - patterns:
          - pattern-inside: |
              containers:
                ...
          - pattern: |
              image: ...
              ...
              securityContext:
                ...
                runAsNonRoot: $VALUE
  - metavariable-pattern:
      metavariable: $VALUE
      pattern: |
        false
  - focus-metavariable: $VALUE
  fix: |
    true
  message: >-
    When running containers in Kubernetes, it's important to ensure that they 
    are properly secured to prevent privilege escalation attacks. 
    One potential vulnerability is when a container is allowed to run 
    applications as the root user, which could allow an attacker to gain 
    access to sensitive resources. To mitigate this risk, it's recommended to 
    add a `securityContext` to the container, with the parameter `runAsNonRoot` 
    set to `true`. This will ensure that the container runs as a non-root user, 
    limiting the damage that could be caused by any potential attacks. By 
    adding a `securityContext` to the container in your Kubernetes pod, you can 
    help to ensure that your containerized applications are more secure and 
    less vulnerable to privilege escalation attacks.
  metadata:
    references:
    - https://kubernetes.io/blog/2016/08/security-best-practices-kubernetes-deployment/
    - https://kubernetes.io/docs/concepts/policy/pod-security-policy/
    - https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html#rule-2-set-a-user
    cwe:
    - 'CWE-250: Execution with Unnecessary Privileges'
    owasp:
    - A05:2021 - Security Misconfiguration
    - A06:2017 - Security Misconfiguration
    category: security
    technology:
    - kubernetes
    subcategory:
    - audit
    likelihood: MEDIUM
    impact: HIGH
    confidence: MEDIUM
  languages: [yaml]
  severity: INFO


Example YAML file without metadata:

rules:
- id: run-as-non-root
  patterns:
  # Capture spec
  - pattern-inside: |
      $SPEC:
        ...
        containers:
          ...
        ...
  - metavariable-regex:
      metavariable: $SPEC
      regex: ^(spec)$
  # No Pod Security Context
  - pattern-not-inside: |
      spec:
        ...
        securityContext:
          ...
        ...
  # Containers defined
  - pattern-inside: |
      $SPEC:
        ...
        containers:
          ...
  # Security Context of all containers in this pod are missing runAsNonRoot
  # So no decision is made to secure at container level in other containers
  - pattern-not-inside: |
      $SPEC:
        ...
        containers:
          ...
          - name: $NAME
            image: ...
            ...
            securityContext:
              ...
              runAsNonRoot: $VALUE
  - focus-metavariable: $SPEC
  fix: |
    $SPEC:
      securityContext:
        runAsNonRoot: true #
  message: >-
    When running containers in Kubernetes, it's important to ensure that they 
    are properly secured to prevent privilege escalation attacks. 
    One potential vulnerability is when a container is allowed to run 
    applications as the root user, which could allow an attacker to gain 
    access to sensitive resources. To mitigate this risk, it's recommended to 
    add a `securityContext` to the container, with the parameter `runAsNonRoot` 
    set to `true`. This will ensure that the container runs as a non-root user, 
    limiting the damage that could be caused by any potential attacks. By 
    adding a `securityContext` to the container in your Kubernetes pod, you can 
    help to ensure that your containerized applications are more secure and 
    less vulnerable to privilege escalation attacks.
  metadata:

Completed YAML file with metadata:

rules:
- id: run-as-non-root
  patterns:
  # Capture spec
  - pattern-inside: |
      $SPEC:
        ...
        containers:
          ...
        ...
  - metavariable-regex:
      metavariable: $SPEC
      regex: ^(spec)$
  # No Pod Security Context
  - pattern-not-inside: |
      spec:
        ...
        securityContext:
          ...
        ...
  # Containers defined
  - pattern-inside: |
      $SPEC:
        ...
        containers:
          ...
  # Security Context of all containers in this pod are missing runAsNonRoot
  # So no decision is made to secure at container level in other containers
  - pattern-not-inside: |
      $SPEC:
        ...
        containers:
          ...
          - name: $NAME
            image: ...
            ...
            securityContext:
              ...
              runAsNonRoot: $VALUE
  - focus-metavariable: $SPEC
  fix: |
    $SPEC:
      securityContext:
        runAsNonRoot: true #
  message: >-
    When running containers in Kubernetes, it's important to ensure that they 
    are properly secured to prevent privilege escalation attacks. 
    One potential vulnerability is when a container is allowed to run 
    applications as the root user, which could allow an attacker to gain 
    access to sensitive resources. To mitigate this risk, it's recommended to 
    add a `securityContext` to the container, with the parameter `runAsNonRoot` 
    set to `true`. This will ensure that the container runs as a non-root user, 
    limiting the damage that could be caused by any potential attacks. By 
    adding a `securityContext` to the container in your Kubernetes pod, you can 
    help to ensure that your containerized applications are more secure and 
    less vulnerable to privilege escalation attacks.
  metadata:
    references:
    - https://kubernetes.io/blog/2016/08/security-best-practices-kubernetes-deployment/
    - https://kubernetes.io/docs/concepts/policy/pod-security-policy/
    - https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html#rule-2-set-a-user
    category: security
    cwe:
    - 'CWE-250: Execution with Unnecessary Privileges'
    owasp:
    - A05:2021 - Security Misconfiguration
    - A06:2017 - Security Misconfiguration
    technology:
    - kubernetes
    subcategory:
    - audit
    likelihood: LOW
    impact: LOW
    confidence: LOW
  languages:
  - yaml
  severity: INFO


Example YAML file without metadata:

rules:
- id: seccomp-confinement-disabled
  patterns:
  - pattern-inside: |
      containers:
        ...
  - pattern: |
      image: ...
      ...
      securityContext:
        ...
        seccompProfile: unconfined
  message: >-
    Container is explicitly disabling seccomp confinement. This runs the
    service in an unrestricted state. Remove 'seccompProfile: unconfined' to
    prevent this.
  metadata:

Completed YAML file with metadata:

rules:
- id: seccomp-confinement-disabled
  patterns:
  - pattern-inside: |
      containers:
        ...
  - pattern: |
      image: ...
      ...
      securityContext:
        ...
        seccompProfile: unconfined
  message: >-
    Container is explicitly disabling seccomp confinement. This runs the
    service in an unrestricted state. Remove 'seccompProfile: unconfined' to
    prevent this.
  metadata:
    cwe:
    - 'CWE-284: Improper Access Control'
    references:
    - https://kubernetes.io/docs/concepts/policy/pod-security-policy/#seccomp
    - https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
    category: security
    technology:
    - kubernetes
    owasp:
    - A05:2017 - Broken Access Control
    - A01:2021 - Broken Access Control
    subcategory:
    - vuln
    likelihood: MEDIUM
    impact: MEDIUM
    confidence: MEDIUM
  languages: [yaml]
  severity: WARNING


Example YAML file without metadata:

apiVersion: v1
kind: Secret
metadata:

Completed YAML file with metadata:

apiVersion: v1
kind: Secret
metadata:
  name: mysecret
type: Opaque
data:
  # ruleid: secrets-in-config-file
  USER NAME: Y2FsZWJraW5uZXk=
  # ok: secrets-in-config-file
  UUID: {UUID}
  # ruleid: secrets-in-config-file
  PASSWORD: UzNjcmV0UGEkJHcwcmQ=
  # ok: secrets-in-config-file
  SERVER: cHJvZA==


Example YAML file without metadata:

rules:
- id: secrets-in-config-file
  patterns:
  - pattern: |
      $KEY: $VALUE
  - pattern-inside: |
      data: ...
  - pattern-inside: |
      kind: Secret
      ...
  - metavariable-regex:
      metavariable: $VALUE
      regex: (?i)^[aA-zZ0-9+/]+={0,2}$
  - metavariable-analysis:
      analyzer: entropy
      metavariable: $VALUE
  message: >-
    Secrets ($VALUE) should not be stored in infrastructure as code files. Use an alternative such as
    Bitnami Sealed Secrets or KSOPS to encrypt Kubernetes Secrets. 
  metadata:

Completed YAML file with metadata:

rules:
- id: secrets-in-config-file
  patterns:
  - pattern: |
      $KEY: $VALUE
  - pattern-inside: |
      data: ...
  - pattern-inside: |
      kind: Secret
      ...
  - metavariable-regex:
      metavariable: $VALUE
      regex: (?i)^[aA-zZ0-9+/]+={0,2}$
  - metavariable-analysis:
      analyzer: entropy
      metavariable: $VALUE
  message: >-
    Secrets ($VALUE) should not be stored in infrastructure as code files. Use an alternative such as
    Bitnami Sealed Secrets or KSOPS to encrypt Kubernetes Secrets. 
  metadata:
    cwe:
    - 'CWE-798: Use of Hard-coded Credentials'
    category: security
    technology:
    - kubernetes
    license: Commons Clause License Condition v1.0[LGPL-2.1-only]
    references:
    - https://kubernetes.io/docs/concepts/configuration/secret/
    - https://media.defense.gov/2021/Aug/03/2002820425/-1/-1/0/CTR_Kubernetes_Hardening_Guidance_1.1_20220315.PDF
    - https://docs.gitlab.com/ee/user/clusters/agent/gitops/secrets_management.html
    - https://www.cncf.io/blog/2021/04/22/revealing-the-secrets-of-kubernetes-secrets/
    - https://github.com/bitnami-labs/sealed-secrets
    - https://www.cncf.io/blog/2022/01/25/secrets-management-essential-when-using-kubernetes/
    - https://blog.oddbit.com/post/2021-03-09-getting-started-with-ksops/
    owasp:
    - A07:2021 - Identification and Authentication Failures
    cwe2022-top25: true
    cwe2021-top25: true
    subcategory:
    - vuln
    likelihood: LOW
    impact: MEDIUM
    confidence: MEDIUM
  languages: [yaml]
  severity: WARNING


Example YAML file without metadata:

rules:
- id: skip-tls-verify-cluster
  pattern: |
    cluster:
      ...
      insecure-skip-tls-verify: true
  message: >-
    Cluster is disabling TLS certificate verification when communicating with
    the server. This makes your HTTPS connections insecure. Remove the
    'insecure-skip-tls-verify: true' key to secure communication.
  metadata:

Completed YAML file with metadata:

rules:
- id: skip-tls-verify-cluster
  pattern: |
    cluster:
      ...
      insecure-skip-tls-verify: true
  message: >-
    Cluster is disabling TLS certificate verification when communicating with
    the server. This makes your HTTPS connections insecure. Remove the
    'insecure-skip-tls-verify: true' key to secure communication.
  metadata:
    cwe:
    - 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://kubernetes.io/docs/reference/config-api/client-authentication.v1beta1/#client-authentication-k8s-io-v1beta1-Cluster
    category: security
    technology:
    - kubernetes
    owasp:
    - A03:2017 - Sensitive Data Exposure
    - A02:2021 - Cryptographic Failures
    subcategory:
    - vuln
    likelihood: MEDIUM
    impact: MEDIUM
    confidence: MEDIUM
  languages: [yaml]
  severity: WARNING


Example YAML file without metadata:

apiVersion: apiregistration.k8s.io/v1beta1
kind: APIService
metadata:

Completed YAML file with metadata:

apiVersion: apiregistration.k8s.io/v1beta1
kind: APIService
metadata:
  name: v1beta1.metrics.k8s.io
# ruleid: skip-tls-verify-service
spec:
  service:
    name: metrics-server
    namespace: kube-system
  group: metrics.k8s.io
  version: v1beta1
  insecureSkipTLSVerify: true
  groupPriorityMinimum: 100
  versionPriority: 100


Example YAML file without metadata:

rules:
- id: skip-tls-verify-service
  pattern: |
    spec:
      ...
      insecureSkipTLSVerify: true
  message: >-
    Service is disabling TLS certificate verification when communicating with
    the server. This makes your HTTPS connections insecure. Remove the
    'insecureSkipTLSVerify: true' key to secure communication.
  metadata:

Completed YAML file with metadata:

rules:
- id: skip-tls-verify-service
  pattern: |
    spec:
      ...
      insecureSkipTLSVerify: true
  message: >-
    Service is disabling TLS certificate verification when communicating with
    the server. This makes your HTTPS connections insecure. Remove the
    'insecureSkipTLSVerify: true' key to secure communication.
  metadata:
    cwe:
    - 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#apiservice-v1-apiregistration-k8s-io
    category: security
    technology:
    - kubernetes
    owasp:
    - A03:2017 - Sensitive Data Exposure
    - A02:2021 - Cryptographic Failures
    subcategory:
    - vuln
    likelihood: MEDIUM
    impact: MEDIUM
    confidence: MEDIUM
  languages: [yaml]
  severity: WARNING


Example YAML file without metadata:

rules:
- id: writable-filesystem-container
  patterns:
  - pattern-inside: |
      containers:
        ...
  - pattern-inside: |
      - name: $CONTAINER
        ...
  - pattern: |
      image: ...
      ...
  - pattern-not: |
      image: ...
      ...
      securityContext:
        ...
        readOnlyRootFilesystem: true
  - focus-metavariable: $CONTAINER
  message: >-
    Container $CONTAINER is running with a writable root filesystem. This may allow
    malicious applications to download and run additional payloads, or modify
    container files. If an application inside a container has to save something
    temporarily consider using a tmpfs. Add 'readOnlyRootFilesystem: true' to this
    container to prevent this.
  metadata:

Completed YAML file with metadata:

rules:
- id: writable-filesystem-container
  patterns:
  - pattern-inside: |
      containers:
        ...
  - pattern-inside: |
      - name: $CONTAINER
        ...
  - pattern: |
      image: ...
      ...
  - pattern-not: |
      image: ...
      ...
      securityContext:
        ...
        readOnlyRootFilesystem: true
  - focus-metavariable: $CONTAINER
  message: >-
    Container $CONTAINER is running with a writable root filesystem. This may allow
    malicious applications to download and run additional payloads, or modify
    container files. If an application inside a container has to save something
    temporarily consider using a tmpfs. Add 'readOnlyRootFilesystem: true' to this
    container to prevent this.
  metadata:
    cwe:
    - 'CWE-732: Incorrect Permission Assignment for Critical Resource'
    owasp:
    - A05:2021 - Security Misconfiguration
    - A06:2017 - Security Misconfiguration
    references:
    - https://kubernetes.io/docs/concepts/policy/pod-security-policy/#volumes-and-file-systems
    - https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
    - https://blog.atomist.com/security-of-docker-kubernetes/
    - https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html#rule-8-set-filesystem-and-volumes-to-read-only
    category: security
    technology:
    - kubernetes
    cwe2021-top25: true
    subcategory:
    - audit
    likelihood: LOW
    impact: MEDIUM
    confidence: LOW
  languages: [yaml]
  severity: WARNING


